<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello SpringBoot]]></title>
    <url>%2Fposts%2F9985%2F</url>
    <content type="text"><![CDATA[Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。— 百度百科 一、SpringBoot优势 SpringBoot 使编码、配置、部署、监控变得更加的简单。 SpringBoot 不是一个全新的框架，而是一种全新的编码规范，它的产生简化了大量的且繁琐的配置文件，让程序员更专注于编码。 SpringBoot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以。 SpringBoot 很容易创建一个独立运行(运行jar，内置servlet容器)、准生产级别的基于Spring框架的项目，使用spring boot你可以不用或者很少的spring配置。 二、SpringBoot常用注解 @SpringBootApplication 查看源码发现该注解是一个组合注解，其中最主要为@SpringBootConfiguration、@EnableAutoConfigration、@ComponentScan 这三个注解 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;&#125; @SpringBootConfiguration 是一个@Configuration注解,主要关注于配置的管理 12345@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; @ComponentScan 是一个用来扫描的注解，它默认会扫描标注了@Controller、@Service、@Repository等注解的类，并实例化这些组件到SpringIOC容器中；它有个配置属性： basePackages，也就是指定扫描的包，如果不指定默认扫描配置了该注解的类的包所在的路径（包括子包） 12345@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123;&#125; @EnableAutoConfigration 是最核心的注解，它提供了关于SpringBoo的运作原理。其中@AutoConfigurationPackage它会自动配置包，它会获取主程序类所在的包路径，并将包路径（包括子包）下的所有组件注册到 SpringIOC 容器中 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;&#125; @Configuration 相当于spring的xml配置文件，作用在类上 @Bean 相当于spring的xml配置文件的bean标签，作用在方法上 @RestController 相当于@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直接填入HTTP响应体中,符合REST风格的控制器 @MapperScan(“xxx.xxx.mapper”) 用来扫描mybatis的mapper层 @ResponseBody 表示该方法的返回结果直接写入HTTP response body中,不会做页面简的跳转 @Component 表示通用组件，当组件不好归类的时候，可以用这个注解进行标注 @AutoWired 用来完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，是根据类型自动装配的 @Qualifier 由于@AutoWired是根据类型装配的，如果有多个类型一致的话，我们用该注解区别 @Resource 跟@AutoWired作用一致，但是它是根据名称自动装配的 @Value 获取配置文件中的值，赋值给属性 三、spring、springMvc、springBoot和springCloud的联系与区别 摘自 1、Spring和SpringMvc Spring: 是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案 SpringMvc: 是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分 2、SpringMvc和SpringBoot SpringMvc: 属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂 SpringBoot: 相对于springMvc框架来说，它更专注于开发微服务后台接口 3、SpringBoot和SpringCloud SpringBoot: 使用了默认大于配置的理念，集成了快速开发的spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务 SpringCloud: 大部分的功能插件都是基于springBoot去实现的，springCloud关注于全局的微服务整合和管理，将多个springBoot单体微服务进行整合以及管理；springCloud依赖于springBoot开发，而springBoot可以独立开发 4、总的来说 Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能 springMvc是基于Servlet的一个MVC框架主要解决WEB开发的问题，因为Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐 为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；但区别于springMvc的是，springBoot专注于微服务方面的接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了 对于springCloud框架来说，它和springBoot一样，注重的是微服务的开发，但是springCloud更关注的是全局微服务的整合和管理，相当于管理多个springBoot框架的单体微服务 三、实例1、所用版本为 Spring-boot-1.5.18.RELEASE2、进入官方的Springboot创建网站 https://start.spring.io/3、选择构建工具为Maven Project、语言为Java、版本为1.5.18；分别填好Group和Artifact,一些其他的依赖目前用不到就不选择；点击Generate Project,之后解压导入到自己的工作空间4、项目结构介绍如图所示 src/main/java 存放程序开发以及主程序入口 src/main/resources 存放配置文件 src/test/java 存放测试程序 application.properties 统一管理配置 pom.xml 统一管理依赖、开发信息… 5、pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.18.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.cheery&lt;/groupId&gt; &lt;artifactId&gt;start&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;start&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;!-- Jdk版本 --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- springboot核心依赖 包括自动配置支持、日志和YAML--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot测试依赖 包括JUnit、Hamcrest、Mockito--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; parent节点导入spring-boot-starter的起步依赖，查看源码发现该依赖也依赖于许多其他不同的依赖包。目的是为了方便其子类直接继承父类的依赖。做过基于Maven分模块的项目就可以明确的了解到，比如有三个不同模块A、B、C，它们需要用到同一个包log4j.jar，如果我们在三个模块的pom.xml文件中分别都要依赖log4j.jar，当log4j.jar的版本发生改变时三个模块的pom.xml文件都需要随之改变，当所需要的共同依赖过多时就会变得非常麻烦，这时候用到parent标签就能解决此问题。 6、XXXApplication 是项目的核心启动类,用@SpringBootApplication注解标明123456@SpringBootApplicationpublic class StartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StartApplication.class, args); &#125;&#125; 7、创建controller包，创建HelloControl控制器1234567@RestControllerpublic class HelloControl &#123; @RequestMapping("/hello") public String hello() &#123; return "Hello SpringBoot 666 !!!"; &#125;&#125; @RestController注解等于 @Controller + @ResponseBody，它会直接向页面返回数据由于springboot默认集成web服务器，所以直接启动StartApplication.class启动类即可，输入 http://127.0.0.1:777/say 访问]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上帝偏爱奔跑者]]></title>
    <url>%2Fposts%2F43820%2F</url>
    <content type="text"><![CDATA[&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;2013年，英超豪门阿森纳足球俱乐部的官方网站发布了一部短片，纪念一位越南的“Running Man”（奔跑者）。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;片头是：每一个故事里都有一个英雄，在这一次的旅途中，英雄出现了——The Running Man。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;短片一经发布，这位越南球迷即刻风靡全球。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;发布前一天，阿森纳队刚刚抵达越南。作为一支英超球队，此番访问越南尚属首次。因此，他们一到，立即引起了轰动。一群狂热的球迷一路奔跑，追赶着偶像乘坐的大巴车。可是，路途很长，车速也不慢。许多人在追赶一段后便放弃了。可是，有一个小伙子却一直坚持着。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;小伙子20岁上下，肤色黝黑，笑容爽朗。尽管大巴车一直以较快的速度前行，可是，他奔跑的速度也不慢，总能适时跟上。小伙子不断地朝车内的群星微笑，向他们挥手，向他们竖起大拇指。车内，球星们也不断回应，露出善意的笑容。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;大步奔跑，不断挥手示意，始终不渝地微笑着。这样的奔跑画面感染了每一位阿森纳球员。他们不断地朝他挥手、微笑、呐喊。车有多快，奔跑便有多快。那是一条长长的道路，途经闹市、街道、人群……一边望向车内，一边急速奔跑，他免不了摔跤。是的，他因一根灯柱而摔倒过，他因一棵大树而撞着了头……每一次，当他摔倒的时候，球星们便发出遗憾之叹。可是随即，他们又欢呼起来：这位了不起的小伙子迅速从地上爬起，仍然保持着那爽朗的笑容，向他们挥手，跟着他们继续前行。他不曾停歇。他只知道，他要一直追赶他们。就如夸父一样，这是一个奔向太阳的史诗般的“英雄”。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;目睹这位充满激情的小伙子奔跑、跌倒、爬起、微笑、再奔跑的过程，球星们对他肃然起敬。所有的球员都跑向车厢那一侧，对他唱了起来：“Sign him up（签下他）！Sign him up……”当然，这是玩笑话，但是，这位球迷身上的热情与激情深深打动了他们。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;他跑了足足5公里。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;他终于乏了。不过，他没有停下，而是换乘一辆摩托车，继续他的“追梦”之路。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;看着他如此不懈地追逐，带队教练终于发话，停下车，为他开启了一扇通向梦想的大门——他有了与阿森纳球员零距离接触的机会。见自己的奔跑没有白费，他振臂欢呼。与他一齐欢呼的，还有车上所有的队员和教练。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;车内，所有的球星一一起立，迎接这位他们刚刚“签下”的新成员。小伙子与他们握手、拥抱、合影，求取签名。他与阿尔特塔并肩而坐，一只手友好地搭在这位著名球星的肩上，另一只手则振臂高呼。这样的一张照片成了阿森纳与球迷合影的经典之照。前锋吉鲁把这一过程完整地拍了下来。当他把视频放上Facebook时，全世界的人都惊叹了。有网友评论：“惊人的耐力、体力和忠诚度！难道他就是温格传说中的7000万引援？签了他！”&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;这是幽默而善意的评论，还有很多人为他喝彩。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;可是，更令人意外的是，2013年7月17日，当阿森纳队与越南队一同出现在绿茵球场时，这位“奔跑者”居然获得了与阿森纳球星一同出场的机会，成为阿森纳“名副其实”的“首发”球员。站在球场上，他与波多尔斯基谈笑风生。他参加双方球员例行的握手仪式。赛后，他还获得了温格赠送的机票、球票和酒店住宿待遇。于是，在将来的某一天，这位幸运的“奔跑者”将前往伦敦，去观看足球比赛。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;对于一位追梦的人来说，这也是他获得的最高礼遇。这位红透全世界的越南小伙子，在忘我的奔跑中追寻到了他的梦想。这不仅仅是一个球迷对于球星的向往和追求，更是关于青春、关于“梦”的追求。就在那样疯狂的奔跑中，他实现了原本遥不可及的梦想。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;所有的球迷在为他高兴的同时，也在艳羡他的境遇。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;然而，并不是所有人都那么“幸运”。因为，世界上分为两种人：一种是奔跑者，一种是观望者。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;而上帝，往往偏爱那些拼尽全力的疯狂的奔跑者。 文章来源链接：http://www.ledu365.com/a/lizhi/49888.html来源：乐读网]]></content>
      <tags>
        <tag>转载</tag>
        <tag>文章推荐</tag>
      </tags>
  </entry>
</search>
