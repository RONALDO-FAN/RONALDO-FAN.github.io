<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pjax学习笔记]]></title>
    <url>%2F2018%2F12%2F06%2Fjquery%2Fpjax%2F</url>
    <content type="text"><![CDATA[一、什么是Pjax? 中文文档解释 pjax是一个jQuery插件，它通过ajax和pushState技术提供了极速的（无刷新ajax加载）浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。 自己理解 Pjax === PushState(修改地址栏的Url) + Ajax(异步无刷新技术)。简单的来说pjax是这两个技术的结合，执行原理ajax负责去后端请求部分html片段或者json数据，通过渲染到指定的div容器中，再由pushstate刷新当前的url地址，但是并不会造成页面的闪动，因此提升用户网页浏览体验。 二、Pjax的工作原理pjax的工作原理是通过ajax从服务器端获取HTML，在页面中用获取到的HTML替换指定容器元素中的内容。然后使用pushState技术更新浏览器地址栏中的当前地址。 三、Pjax的优缺点 优点： 不存在页面资源（js/css）的重复加载和应用。 如果服务器端配置了pjax，它可以只渲染页面局部内容，从而避免服务器渲染完整布局的额外开销。 缺点 不支持一些低版本的浏览器(如IE系列)，因为pushState是html5中history的新特性，在某些旧版浏览器中可能不支持。 使服务端处理变得复杂。 pjax依赖于jQuery 1.8或者更高版本。 四、Pjax起步 通过npm安装 or 通过js引入(首先得引入jqeury)12$ npm install jquery-pjaxhttps://raw.github.com/defunkt/jquery-pjax/master/jquery.pjax.js 五、Pjax方法 $.fn.pjax 概述 1$(document).pjax(selector, [container], options) 1.selector：string类型，用于click 事件委托 的选择器。 2.container：string类型，用于标识唯一pjax容器的选择器。 3.options object类型，包含下列选项。 选项 默认值 说明 timeout 650 ajax超时时间（毫秒），超时后强制刷新整个页面 push true 使用 pushState 在浏览器中添加历史记录 replace false 替换URL地址但不添加浏览器历史记录 type “GET” 请求类型 dataType “html” 服务器端返回的数据类型 type “GET” 请求类型 url link.href string或function，返回ajax请求响应的URL 全局使用$.pjax.defaults对象改变默认配置，如下 $.pjax.defaults.timeout = 1200 $.fn.pjax 用法 最简单常见的pjax使用方法如下： 1$(document).pjax('a', '#pjax-container') pjax()方法能若干个参数，上文涉及到的’a’和’#pjax-container’。’a’代表所有的a标签链接，而’#pjax-container’代表需要替换内容的容器。通过这种方式可以让页面中所有的链接都实现pjax加载，并指定ID为pjax-container的作为容器元素。 如果我们想指定a标签作为pjax链接使用方法如下： 1$(document).pjax('[data-pjax] a, a[data-pjax]', '#pjax-container') 那么我们可以用data-pjax来注明这是一个pjax链接，然后使用a[data-pjax]来代替全局选择器a。 六、事件 $.pjax.click 点击事件 本示例使用当前的click上下文来设置一个祖先元素作为容器：1234567if ($.support.pjax) &#123; $(document).on('click', 'a[data-pjax]', function(event) &#123; var container = $(this).closest('[data-pjax-container]') var containerSelector = '#' + container.id $.pjax.click(event, &#123;container: containerSelector&#125;) &#125;)&#125; $.pjax.submit 表单提交事件 通过pjax提交表单123$(document).on('submit', 'form[data-pjax]', function(event) &#123; $.pjax.submit(event, '#pjax-container')&#125;) $.pjax.reload 重载事件 使用pjax机制发起一个当前URL的请求到服务器，并且通过响应的内容替换容器元素中的内容，同时不添加浏览器历史记录。1$.pjax.reload('#pjax-container', options) $.pjax 手动调用pjax事件 主要用于非click事件发起pjax请求的情况。如果可以获得click事件，请使用$.pjax.click(event)来代替。1234function applyFilters() &#123; var url = urlForFilters() $.pjax(&#123;url: url, container: '#pjax-container'&#125;)&#125; 七、文档链接：https://github.com/defunkt/jquery-pjax来源：github链接：http://bsify.admui.com/jquery-pjax/来源：bsifyEND🙈]]></content>
      <tags>
        <tag>转载</tag>
        <tag>学习笔记</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活在你的时区]]></title>
    <url>%2F2018%2F12%2F06%2Farticle%2F%E6%B4%BB%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%97%B6%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[纽约时间比加州时间早三个小时，New York is 3 hours ahead of California但加州时间并没有变慢。but it does not make California slow有人22岁就毕业了，Someone graduated at the age of 22但等了五年才找到好的工作！but waited 5 years before securing a good job有人25岁就当上CEO，Someone became a CEO at 25却在50岁去世。and died at 50也有人迟到50岁才当上CEO，While another became a CEO at 50然后活到90岁。and lived to 90 years.有人依然单身，Someone is still single同时也有人已婚。while someone else got married.奥巴马55岁就退休，Obama retires at 55川普70岁才开始当总统。but Trump starts at 70世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone身边有些人看似走在你前面，People around you might seem to go ahead of you也有人看似走在你后面。some might seem to be behind you但其实每个人在自己的时区都有自己的步伐。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours生命就是等待正确的行动时机。Life is about waiting for the right moment to act所以，放轻松、你没有落后、你没有领先。So, RELAX、You’re not LATE、You’re not EARLY在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 文章来源作者：HIGO链接：https://www.zhihu.com/question/38874036/answer/458029368来源：知乎END🙈]]></content>
      <tags>
        <tag>转载</tag>
        <tag>文章推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用指令]]></title>
    <url>%2F2018%2F12%2F06%2Fhexo%2Fhexo-order%2F</url>
    <content type="text"><![CDATA[一、Hexo安装及初始化123npm install hexo-cli -g #安装npm update hexo -g #升级hexo init #初始化 二、常用指令 新建草稿 1hexo new draft "文章名称" 新建文章 1hexo n "文章名称" === hexo new "文章名称" 发布文章 1hexo publish "文章名称" 启动服务 1hexo s === hexo server 部署至服务器 1hexo d === hexo deploy 清除缓存 1hexo clean 更改端口 1hexo server -p 端口号 自定义IP 1hexo s -i ip地址 生成静态页面至public目录 1hexo g === hexo generate Ps:可与hexo g 合并为 hexo d -g / hexo g -d 三、插件推荐 1 文章置顶12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 文章添加top值即可 2 文章封面1npm install --save hexo-less 一张图片外链和less标签即可,该封面图不会出现在正文效果图如下 四、报错异常 1 找不到git部署及解决方法12ERROR Deployer not found: gitnpm install hexo-deployer-git --save 2 部署类型设置git –&gt;打开你博客的根目录，找到 _config.yml配置文件123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:github用户名/github用户名.github.io branch: master 五、查看更多详情 Hexo官方文档 https://hexo.io/zh-cn/ 大佬们的教程 https://segmentfault.com/a/1190000002632530 https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.bilibili.com/video/av17653359 END🙈]]></content>
      <tags>
        <tag>原创</tag>
        <tag>学习笔记</tag>
        <tag>Hexo指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(一)]]></title>
    <url>%2F2018%2F12%2F05%2Fmybatis%2Fmybatis1%2F</url>
    <content type="text"><![CDATA[MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。是一个基于Java的持久层框架。 一、理解Mybatis? MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。 MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 二、与Hibernate对比 MyBatis与Hibernate都属于ORM框架，为数据层提供持久化操作的支持。 由于MyBatis等接近于JDBC的开发，所以相对于Hibernate更加的简单易学。 Hibernate开发者不要关注SQL的生成和结果的映射，而Mybatis需要手动配置关系和SQL。 Hibernate与具体的数据库关联配置对应的XML即可，所执行的HQL语句与数据库无关，移植性强。而Mybatis直接使用的是SQL语句，相对没那么灵活。 Mybatis的灵活性、执行效率略高于Hibernate。 三、Mybatis的优缺点 优点： SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优 化，并可重用，适合多表的复杂查询 提供XML标签，支持编写动态SQL语句。 提供映射标签，支持对象与数据库的ORM字段关系映射。 缺点 SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。 SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 四、代码案例1、编写Mybatis核心配置文件【 mybatis-core.xml 】12345678910111213141516171819&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.fan.entity.StudentEntity" alias="StudentEntity"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/public"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="xxx.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 释意: typeAlias用于存放实体类别名的集合 — typeAlias中的type代表实体类 — alias我们自己自定义的别名 environments环境 default里面的值可以是生产环境、测试环境、开发环境… transactionManager事务管理 type默认为JDBC dataSource是数据库连接的基本信息 mapper中的resource代表应用实体类的Mapper 2、编写Mybatis核心配置文件【 mybatis-core.xml 】123456789101112131415161718192021&lt;mapper namespace="StuMapper"&gt; &lt;select id="selCount" resultType="int"&gt; select count(*) from student &lt;/select&gt; &lt;select id="selById" parameterType="int" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.stuId = #&#123;id&#125; &lt;/select&gt; &lt;insert id="addOne" parameterType="StudentEntity"&gt; INSERT INTO student VALUES(NULL,#&#123;stuName&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;address&#125;,NULL) &lt;/insert&gt; &lt;delete id="delOne" parameterType="int"&gt; DELETE FROM student WHERE student.stuId = #&#123;id&#125; &lt;/delete&gt; &lt;update id="modifyOne" parameterType="StudentEntity"&gt; UPDATE student SET stuName = #&#123;stuName&#125; WHERE stuId = #&#123;stuId&#125; &lt;/update&gt;&lt;/mapper&gt; 释意: mapper中的namespace是独立唯一的 DML语句中支持写原生的SQL语句 id可以形象的理解为方法名，但是同时也是独立唯一的 parameterType代表传过来的参数类型 resultType代表返回值 #{xxx} 可以理解为占位符 3、简单的使用123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; Reader reader = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory factory = null; SqlSession session = null; try &#123; //1.加载配置文件 reader = Resources.getResourceAsReader("mybatis-core.xml"); //2.得到工厂的创建对象 builder = new SqlSessionFactoryBuilder(); //3.得到工厂对象 factory = builder.build(reader); //4.得到session session = factory.openSession(); //5.执行语句 StudentEntity student = session.selectOne("StuMapper.selById", 100); //StuMapper--&gt; StudentMapper.xml中的namespace。 selById--&gt; 为其中的id 。 100--&gt; 实参 System.out.println("学生名为--&gt;" + student.getStuName()); session.commit(); //修改、新增语句记得提交事务 &#125; catch (Exception e) &#123; session.rollback(); e.printStackTrace(); &#125; finally &#123; if (session != null) &#123; session.close(); &#125; &#125; &#125;&#125; END🙈]]></content>
      <tags>
        <tag>原创</tag>
        <tag>学习笔记</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
