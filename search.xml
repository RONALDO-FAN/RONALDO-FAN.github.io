<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis-generator逆向工程生成mapper和pojo]]></title>
    <url>%2Fposts%2F1596%2F</url>
    <content type="text"><![CDATA[一、Mybatis工具 http://www.mybatis.tk MyBatis-Spring-Boot https://github.com/abel533/MyBatis-Spring-Boot Mybatis 通用 Mapper3 https://github.com/abel533/Mapper Mybatis 分页插件 PageHelper https://github.com/pagehelper/Mybatis-PageHelper 二、集成MyBatis, 分页插件 PageHelper, 通用 Mapper, 数据源 druid使用逆向工程可以针对数据库表自动生成mybatis执行所需要的Pojo、Mapper xml文件、Mapper Interface接口文件;可以帮我们自动完成许多没必要而又容易出错的步骤。 1、项目依赖123456789101112131415161718&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--mapper--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--pagehelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 2、Spring DevTools 配置在src/main/resources中创建META-INF目录，在此目录下添加spring-devtools.properties配置，内容如下：12restart.include.mapper=/mapper-[\\w-\\.]+jarrestart.include.pagehelper=/pagehelper-[\\w-\\.]+jar 3、集成 MyBatis Generator 运行如下maven命令1mvn mybatis-generator:generate 4、application.yml 配置 具体的路径换成你自己的 1234567891011121314151617181920212223242526272829303132# 数据源spring: datasource: url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: root driver-class-name: com.mysql.jdbc.Driver # druid druid: initial-size: 1 min-idle: 1 max-active: 20 test-on-borrow: true stat-view-servlet: allow: true# mybatismybatis: type-aliases-package: com.cheery.pojo mapper-locations: classpath:mapper/*.xml# mapper的通用配置mapper: mappers: com.cheery.utils.MyMapper not-empty: false identity: MYSQL# pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 5、分别创建如下目录java路径下 xxx.xxx.mapper / xxx.xxx.pojo / xxx.xxx.utilsresources路径下 mapper / META-INF6、resources路径下 添加generatorConfig.xml 根据自己的要求修改1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="MysqlContext" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;property name="mappers" value="com.cheery.utils.MyMapper"/&gt; &lt;/plugin&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/test" userId="root" password="root"/&gt; &lt;!-- 对于生成的pojo所在包 --&gt; &lt;javaModelGenerator targetPackage="com.cheery.pojo" targetProject="src/main/java"/&gt; &lt;!-- 对于生成的mapper所在目录 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"/&gt; &lt;!-- 配置mapper对应的java映射 --&gt; &lt;javaClientGenerator targetPackage="com.cheery.mapper" targetProject="src/main/java" type="XMLMAPPER"/&gt; &lt;!-- 需要逆向生成的表名 --&gt; &lt;table tableName="master"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 7、在xxx.xxx.utils包下创建 GeneratorDisplay.class1234567891011121314151617181920212223public class GeneratorDisplay &#123; private void generator() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;&gt;(); boolean overwrite = true; //指定 逆向工程配置文件 File configFile = new File("src/main/resources/generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; GeneratorDisplay generatorDisplay = new GeneratorDisplay(); generatorDisplay.generator(); System.out.println("****生成成功!!!****"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 8、在xxx.xxx.utils包下创建 MyMapper.interface1234public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; //TODO //FIXME 特别注意，该接口不能被扫描到，否则会出错&#125; 9、运行GeneratorDisplay.class中的main方法，出现如下信息表示成功10、我们就会发现xxx.xxx.mapper 和 xxx.xxx.pojo，帮我们自动生成了MasterMapper 和 Master；在resources/mapper 帮我们生成了MasterMapper.xml11、下篇文章基于它CURD操作]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringBoot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 模板引擎]]></title>
    <url>%2Fposts%2F8803%2F</url>
    <content type="text"><![CDATA[Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎。Thymeleaf的主要目标是为您的开发工作流程带来优雅的自然模板,可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。 — Thymeleaf官方介绍 一、thymeleaf介绍 Thymeleaf 相似的模板引擎有JSP、Velocity、Freemarker Thymeleaf 是Web和独立环境的现代服务器端 Java 模板引擎，能够处理HTML，XML，JavaScript，CSS 甚至纯文本 Thymeleaf 也从一开始就设计了Web标准 - 特别是 HTML5 - 允许您创建完全验证的模板，SpringBoot 官方推荐使用thymeleaf 二、thymeleaf特点 摘自 Thymeleaf 在有无网络环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果 Thymeleaf 开箱即用的特性；它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰 Thymeleaf 提供spring标准方言和一个与SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 三、标准表达式语法 详见 变量表达式 ${…} 变量表达式是OGNL表达式或Spring EL表达式【 如果将Thymeleaf 与Spring - 集成在上下文变量上(也称为Spring术语中的模型属性) 】 1$&#123;session.user.name&#125; 或者作用于标签上 12&lt;div th:text="$&#123;user.name&#125;"&gt;&lt;/div&gt; -- 输出文本值&lt;div th:each="$&#123;user:users&#125;"&gt;&lt;/div&gt; -- 遍历集合对象 选择表达式 *{…} 它不是整个上下文变量映射上执行，而是在先前选择的对象，所作用的对象由th:object属性 如1234&lt;ul th:object="$&#123;users&#125;"&gt; &lt;li th:text="*&#123;name&#125;"&gt;&lt;/li&gt; &lt;li th:text="*&#123;gender&#125;"&gt;&lt;/li&gt;&lt;/ul&gt; 消息 (i18n) 表达式 #{…} 消息表达式(通常称为文本外部化，国际化或i18n)允许从外部源。在Spring应用程序中，它将自动与Spring的MessageSource机制集成 如 12#&#123;main.title&#125;#&#123;message.entrycreated($&#123;entryId&#125;)&#125; 以下是在模板中使用它们的方式: 123456&lt;table&gt; ... &lt;th th:text="#&#123;header.address.city&#125;"&gt;...&lt;/th&gt; &lt;th th:text="#&#123;header.address.country&#125;"&gt;...&lt;/th&gt; ...&lt;/table&gt; 链接 (URL) 表达式 @{…} 用来绑定一些链接和资源的引用 如12&lt;script th:src="@&#123;/static/js/index.js&#125;" charset="UTF-8"&gt;&lt;/script&gt;&lt;a th:herf="@&#123;https://www.cronaldo7.cn/&#125;"&gt;thymeleaf方式&lt;/a&gt; 片段表达式 ~{…} 片段表达式是一种简单的方法用来表示标记的片段并将其移动到模板中，由于这些表达式，片段可以被复制，传递给其他模板的参数等等。常见的有th:insert或th:replace1&lt;div th:insert="~&#123;commons :: main&#125;"&gt;...&lt;/div&gt; 四、thymeleaf布局感觉就是比JSP的layout布局用的舒服 如定义一段html代码123&lt;footer th:fragment="copy"&gt; 版权所有 xxx&lt;/footer&gt; 引用 th:include是引入 th:replace是替换1234&lt;body&gt; &lt;div th:include="footer :: copy"&gt;&lt;/div&gt; &lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;/body&gt; 五、实例 pom.xml 加入web和thymeleaf依赖 12345678910&lt;!-- web支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- thymeleaf模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 配置thymeleaf 12345678spring: thymeleaf: cache: false prefix: classpath:/templates/ suffix: .html mode: HTML5 encoding: UTF-8 content-type: text/html 实体类 1234567891011@Data@AllArgsConstructorpublic class UserEntity &#123; private long id; private String userName; private String gender; private int age; private String address; private Date birthday; private String desc;&#125; 控制器 转发一个user对象和users集合到 src/mian/resources/templates/thymeleaf/demo.html 页面 1234567891011121314151617181920212223@Controller@RequestMapping("user")public class UserControl &#123; @RequestMapping("/index") public String index(ModelMap map) throws Exception &#123; UserEntity user = new UserEntity(101, "张三", "男", 18, "湖南长沙", new Date(), "&lt;font color='red'&gt;&lt;b&gt;Hello World!!!&lt;/b&gt;&lt;/font&gt;"); UserEntity user1 = new UserEntity(102, "李四", "女", 20, "湖南岳阳", new Date(), "&lt;font color='red'&gt;&lt;b&gt;Hello 666!!!&lt;/b&gt;&lt;/font&gt;"); List&lt;UserEntity&gt; userList = new ArrayList&lt;&gt;(); userList.add(user); userList.add(user1); map.addAttribute("user", user); map.addAttribute("users", userList); return "thymeleaf/demo"; &#125; @RequestMapping("/refer") public String refer(UserEntity user) throws Exception &#123; System.out.println("****进入此方法****"); System.out.println(user.getUserName()); return "/user/index"; &#125;&#125; 常用标签的使用 th:text 123456789&lt;div&gt; &lt;p th:text="$&#123;user.id&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;user.userName&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;user.gender&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;user.age&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;user.address&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;user.birthday&#125;"&gt;&lt;/p&gt; &lt;p th:text="$&#123;#dates.format(user.birthday,'yyyy-MM-dd')&#125;"&gt;&lt;/p&gt;&lt;/div&gt; th:object 123456789&lt;div th:object="$&#123;user&#125;"&gt; &lt;p th:text="*&#123;id&#125;"&gt;&lt;/p&gt; &lt;p th:text="*&#123;userName&#125;"&gt;&lt;/p&gt; &lt;p th:text="*&#123;gender&#125;"&gt;&lt;/p&gt; &lt;p th:text="*&#123;age&#125;"&gt;&lt;/p&gt; &lt;p th:text="*&#123;address&#125;"&gt;&lt;/p&gt; &lt;p th:text="*&#123;birthday&#125;"&gt;&lt;/p&gt; &lt;p th:text="*&#123;#dates.format(birthday,'yyyy-MM-dd')&#125;"&gt;&lt;/p&gt;&lt;/div&gt; text普通文本和utext转义文本的区别 1234&lt;div&gt; &lt;p th:text="$&#123;user.desc&#125;"&gt;&lt;/p&gt; &lt;p th:utext="$&#123;user.desc&#125;"&gt;&lt;/p&gt;&lt;/div&gt; url使用和静态资源的引入 123456&lt;div&gt; &lt;a href="https://www.cronaldo7.cn/"&gt;普通方式&lt;/a&gt; &lt;a th:herf="@&#123;https://www.cronaldo7.cn/&#125;"&gt;thymeleaf方式&lt;/a&gt;&lt;/div&gt;----------------------------------------------------------------&lt;script th:src="@&#123;/static/js/index.js&#125;" charset="UTF-8"&gt;&lt;/script&gt; form表单 123456&lt;div&gt; &lt;form th:action="@&#123;/user/refer&#125;" th:object="$&#123;user&#125;" method="post" th:method="post"&gt; &lt;input type="text" th:field="*&#123;userName&#125;" /&gt; &lt;br/&gt; &lt;input type="submit" /&gt;&lt;/form&gt;&lt;/div&gt; if 1234567&lt;div&gt; &lt;div th:if="$&#123;user.age == 18&#125;"&gt;十八岁你好!!!&lt;/div&gt; &lt;div th:if="$&#123;user.age gt 18&#125;"&gt;你老啦&lt;/div&gt; &lt;div th:if="$&#123;user.age lt 18&#125;"&gt;年轻人&lt;/div&gt; &lt;div th:if="$&#123;user.age ge 18&#125;"&gt;这是大于等于哦&lt;/div&gt; &lt;div th:if="$&#123;user.age le 18&#125;"&gt;这是小于等于哦&lt;/div&gt;&lt;/div&gt; switch 1234&lt;div th:switch="$&#123;user.id&#125;"&gt; &lt;p th:case="'101'"&gt;超级管理员用户&lt;/p&gt; &lt;p th:case="*"&gt;其他用户&lt;/p&gt;&lt;/div&gt; each 1234567891011121314151617&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;住址&lt;/td&gt; &lt;td&gt;生日&lt;/td&gt;&lt;/tr&gt; &lt;tr th:each="person:$&#123;users&#125;"&gt; &lt;td th:text="$&#123;person.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;person.userName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;person.gender&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;person.age&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;person.address&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(person.birthday,'yyyy-MM-dd')&#125;"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 界面]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 常规配置]]></title>
    <url>%2Fposts%2F9175%2F</url>
    <content type="text"><![CDATA[一、404、500错误页面配置 创建ErrorPageConfig类，并添加如下代码，错误页面要放在src/main/resources/static目录下1234567891011@Configurationpublic class ErrorPageConfig &#123; @Bean public EmbeddedServletContainerCustomizer containerCustomizer() &#123; return (container -&gt; &#123; ErrorPage error404Page = new ErrorPage(HttpStatus.NOT_FOUND, "/404.html"); ErrorPage error500Page = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/500.html"); container.addErrorPages(error404Page, error500Page); &#125;); &#125;&#125; 二、application.properties或application.yml配置12]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 入门篇]]></title>
    <url>%2Fposts%2F9985%2F</url>
    <content type="text"><![CDATA[Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。— 百度百科 一、SpringBoot优势 SpringBoot 使编码、配置、部署、监控变得更加的简单。 SpringBoot 不是一个全新的框架，而是一种全新的编码规范，它的产生简化了大量的且繁琐的配置文件，让程序员更专注于编码。 SpringBoot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以。 SpringBoot 很容易创建一个独立运行(运行jar，内置servlet容器)、准生产级别的基于Spring框架的项目，使用spring boot你可以不用或者很少的spring配置。 二、SpringBoot常用注解 @SpringBootApplication 查看源码发现该注解是一个组合注解，其中最主要为@SpringBootConfiguration、@EnableAutoConfigration、@ComponentScan 这三个注解 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;&#125; @SpringBootConfiguration 是一个@Configuration注解,主要关注于配置的管理 12345@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; @ComponentScan 是一个用来扫描的注解，它默认会扫描标注了@Controller、@Service、@Repository等注解的类，并实例化这些组件到SpringIOC容器中；它有个配置属性： basePackages，也就是指定扫描的包，如果不指定默认扫描配置了该注解的类的包所在的路径（包括子包） 12345@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123;&#125; @EnableAutoConfigration 是最核心的注解，它提供了关于SpringBoo的运作原理。其中@AutoConfigurationPackage它会自动配置包，它会获取主程序类所在的包路径，并将包路径（包括子包）下的所有组件注册到 SpringIOC 容器中 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;&#125; @Configuration 相当于spring的xml配置文件，作用在类上 @Bean 相当于spring的xml配置文件的bean标签，作用在方法上 @RestController 相当于@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直接填入HTTP响应体中,符合REST风格的控制器 @MapperScan(“xxx.xxx.mapper”) 用来扫描mybatis的mapper层 @ResponseBody 表示该方法的返回结果直接写入HTTP response body中,不会做页面简的跳转 @Component 表示通用组件，当组件不好归类的时候，可以用这个注解进行标注 @AutoWired 用来完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，是根据类型自动装配的 @Qualifier 由于@AutoWired是根据类型装配的，如果有多个类型一致的话，我们用该注解区别 @Resource 跟@AutoWired作用一致，但是它是根据名称自动装配的 @Value 获取配置文件中的值，赋值给属性 三、spring、springMvc、springBoot和springCloud的联系与区别 摘自 1、Spring和SpringMvc Spring: 是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案 SpringMvc: 是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分 2、SpringMvc和SpringBoot SpringMvc: 属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂 SpringBoot: 相对于springMvc框架来说，它更专注于开发微服务后台接口 3、SpringBoot和SpringCloud SpringBoot: 使用了默认大于配置的理念，集成了快速开发的spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务 SpringCloud: 大部分的功能插件都是基于springBoot去实现的，springCloud关注于全局的微服务整合和管理，将多个springBoot单体微服务进行整合以及管理；springCloud依赖于springBoot开发，而springBoot可以独立开发 4、总的来说 Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能 springMvc是基于Servlet的一个MVC框架主要解决WEB开发的问题，因为Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐 为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；但区别于springMvc的是，springBoot专注于微服务方面的接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了 对于springCloud框架来说，它和springBoot一样，注重的是微服务的开发，但是springCloud更关注的是全局微服务的整合和管理，相当于管理多个springBoot框架的单体微服务 三、实例1、所用版本为 Spring-boot-1.5.18.RELEASE2、进入官方的Springboot创建网站 https://start.spring.io/3、选择构建工具为Maven Project、语言为Java、版本为1.5.18；分别填好Group和Artifact,一些其他的依赖目前用不到就不选择；点击Generate Project,之后解压导入到自己的工作空间4、项目结构介绍如图所示 src/main/java 存放程序开发以及主程序入口 src/main/resources 存放配置文件 src/test/java 存放测试程序 application.properties 统一管理配置 pom.xml 统一管理依赖、开发信息… 5、pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.18.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.cheery&lt;/groupId&gt; &lt;artifactId&gt;start&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;start&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;!-- Jdk版本 --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- springboot核心依赖 包括自动配置支持、日志和YAML--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot测试依赖 包括JUnit、Hamcrest、Mockito--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; parent节点导入spring-boot-starter的起步依赖，查看源码发现该依赖也依赖于许多其他不同的依赖包。目的是为了方便其子类直接继承父类的依赖。做过基于Maven分模块的项目就可以明确的了解到，比如有三个不同模块A、B、C，它们需要用到同一个包log4j.jar，如果我们在三个模块的pom.xml文件中分别都要依赖log4j.jar，当log4j.jar的版本发生改变时三个模块的pom.xml文件都需要随之改变，当所需要的共同依赖过多时就会变得非常麻烦，这时候用到parent标签就能解决此问题。 6、XXXApplication 是项目的核心启动类,用@SpringBootApplication注解标明123456@SpringBootApplicationpublic class StartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StartApplication.class, args); &#125;&#125; 7、创建controller包，创建HelloControl控制器1234567@RestControllerpublic class HelloControl &#123; @RequestMapping("/hello") public String hello() &#123; return "Hello SpringBoot 666 !!!"; &#125;&#125; @RestController注解等于 @Controller + @ResponseBody，它会直接向页面返回数据由于springboot默认集成web服务器，所以直接启动StartApplication.class启动类即可，输入 http://127.0.0.1:777/say 访问]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VsCode搭建SpringBoot运行环境]]></title>
    <url>%2Fposts%2F6124%2F</url>
    <content type="text"><![CDATA[Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言、语法高亮、智能代码补全、自定义快捷键、括号匹配和颜色区分、代码片段、代码对比 Diff、GIT命令 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux，运行流畅。在这么多优势下，被誉为宇宙最强IDE也是理所应当的。 一、开发环境搭建 1) 系统需安装JDK和Maven，并分别配置好相关环境变量 2) 配置vscode的JDK和Maven，打开vscode的User Settings，JDK和Maven改成你本地的路径即可1234567891011121314151617181920&#123; "java.errors.incompleteClasspath.severity": "ignore", // jdk目录 "java.home":"C:\\Program Files\\Java\\jdk1.8.0_181", // maven settings.xml路径 "java.configuration.maven.userSettings": "C:\\A-Work\\Resources\\apache-maven-3.6.0\\conf\\settings.xml", // maven mvn.cmd路径 "maven.executable.path": "C:\\A-Work\\Resources\\apache-maven-3.6.0\\bin\\mvn.cmd", "maven.terminal.useJavaHome": true, // 指定jdk环境变量 "maven.terminal.customEnv": [ &#123; "environmentVariable": "JAVA_HOME", "value": "C:\\Program Files\\Java\\jdk1.8.0_181" &#125; ], "explorer.confirmDelete": false, // 使用图标主题 "workbench.iconTheme": "vscode-icons",&#125; 如果Maven jar包下载很慢的话 推荐在你本地的setting.xml配置阿里云镜像123456789101112131415161718192021222324&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;repoone&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;repotwo&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 3) 进入vscode官方插件库安装java相关插件，或直接打开搜索vscode安装 JAVA基本扩展 Language support for Java ™ for Visual Studio Code Debugger for Java Java Test Runner Java Extension Pack Java Dependency Viewer 其他扩展 如SpringBoot Tomcat icon-theme Spring Boot Extension Pack TomCat for Java vscode-icon 4) 全部安装完后重启生效 二、创建Spring Boot项目 使用快捷键F1或组合键【Ctrl+Shift+P】打开如下命令窗口 输入spring initializr选择创建一个Maven项目 -&gt;类型选择Java -&gt;输入组织ID -&gt;输入项目名称 -&gt;选择SpringBoot的版本 -&gt;选择SpringBoot需要的模块 (web / mysql / mybatis…) 生成如下项目结构 在com.cheery.start目录下创建一个controller包 编写HelloControl控制器 1234567@RestControllerpublic class HelloControl&#123; @RequestMapping("/say") public String hello()&#123; return "Spring Boot For CRONALDO"; &#125;&#125; 进入SpringBoot启动类 点击Run或Debug启动项目 访问http://127.0.0.1:8080/say 二、运行Java Web项目 导入任意一个Web项目，找到编译目录下的war包，右键选择Run on Tomcat Server | Debug on Tomcat Server 第一次运行会弹出一个窗口让你选择 所依赖的Tomcat 测试接口和界面都完美运行]]></content>
      <tags>
        <tag>转载</tag>
        <tag>后端</tag>
        <tag>VsCode</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM 注解版整合]]></title>
    <url>%2Fposts%2F3167%2F</url>
    <content type="text"><![CDATA[一、回顾 Spring Mvc 常用注解 SSM 非注解版整合版本 SSM 非注解版整合版本完整项目 二、SSM搭建环境 工具 Windows 10 IntelliJ IDEA 2018.3.3 Navicat Premium 12 PostMan 环境 Jdk 1.8 MySQL 5.7 Apache-Tomcat 9 Apache-Maven 3.6.0 技术 Spring 4.3.9.RELEASE Mybatis 3.2.8 Druid 1.1.10 Layui 2.4.5 三、使用 IDEA+Maven 构建 SSM 项目1、省略创建步骤2、编写配置文件1) pom.xml 与 SSM 非注解版整合版本 的pom.xml一致 2) web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;!-- 放行静态资源 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt; &lt;url-pattern&gt;*.svg&lt;/url-pattern&gt; &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt; &lt;url-pattern&gt;*.woff&lt;/url-pattern&gt; &lt;url-pattern&gt;*.ttf&lt;/url-pattern&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- druid连接池 --&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置拦截SpringMvc核心拦截器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 设置springmvc配置文件位置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/SpringMvc-core.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置该启动器开启的顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 加载log4j --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/Spring-core.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;list.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 3) log4j.properties 与 SSM 非注解版整合版本 的log4j.properties一致 4) druid.properties 与 SSM 非注解版整合版本 的druid.properties一致 5) SpringMvc-core.xml springmvc配置1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"&gt; &lt;!-- 扫描Controller注解 --&gt; &lt;context:component-scan base-package="com.fan.controllers"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="order" value="0"/&gt; &lt;property name="prefix" value="/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;property name="contentType" value="text/html;charset=UTF-8"/&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.InternalResourceView"/&gt; &lt;/bean&gt;&lt;/beans&gt; 6) mybatis-core.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 启用二级缓存 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- 使用getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;/settings&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.fan.entity.BrandEntity" alias="BrandEntity"/&gt; &lt;typeAlias type="com.fan.entity.MasterEntity" alias="MasterEntity"/&gt; &lt;typeAlias type="com.fan.entity.MobileEntity" alias="MobileEntity"/&gt; &lt;typeAlias type="com.fan.utils.PageHelper" alias="PageHelper"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 7) Spring-core.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"&gt; &lt;!-- 扫描Dao和Service注解 --&gt; &lt;context:component-scan base-package="com.fan.dao.*,com.fan.service"/&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1、加载druid.properties连接池属性 --&gt; &lt;context:property-placeholder location="classpath:configs/druid.properties"/&gt; &lt;!-- 2、数据库Druid连接池 --&gt; &lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;theUser&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;property name="filters" value="$&#123;filters&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;"/&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;"/&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;"/&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;/bean&gt; &lt;!-- 3、配置sessionFactory对象 --&gt; &lt;bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt; &lt;!-- 关联mybatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:configs/mybatis-core.xml"/&gt; &lt;!-- 关联mapper配置文件 --&gt; &lt;property name="mapperLocations" value="classpath:configs/mappers/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 4、提供执行CURD的sqlSessionTemplate对象注入到dao层 --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 事务配置 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt; &lt;/bean&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="del*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="add*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="REQUIRED"/&gt; &lt;tx:method name="get*" propagation="REQUIRED"/&gt; &lt;tx:method name="modify*" propagation="REQUIRED"/&gt; &lt;tx:method name="*" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切入点 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.fan.service.*.* (..))" id="txPointCut"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 四、案例 【 分页查询全部数据 – 对该数据进行增删改 】1) 创建实体【 MobileEntity手机 】和【 BrandEntity品牌 】1234567@Datapublic class BrandEntity implements Serializable &#123; private static final long serialVersionUID = -3583081687230898634L; private long brandId; private String brandName; private String desc;&#125; 1234567891011@Datapublic class MobileEntity implements Serializable &#123; private static final long serialVersionUID = -7891355486597914597L; private long mobileId; private long brandId; private String type; private String os; private String cpu; private long ramSize; private long diskSize;&#125; 2) 创建Dao接口【 IMobileDao 】和【 IBrandDao 】123456789101112public interface IMobileDao &#123; /** 查询全部手机 传入分页工具类 */ List&lt;HashMap&gt; queryAll(PageHelper page); /** 查询手机总数 */ int queryCount(); /** 删除手机信息 支持批量删除 */ int delBatch(Integer[] idArr); /** 修改手机信息 */ int modifyOne(MobileEntity mobile); /** 保存手机信息 */ int saveOne(MobileEntity mobile);&#125; 1234public interface IBrandDao &#123; /** 查询全部品牌信息 */ List&lt;HashMap&gt; queryAll();&#125; 3) 创建Mapper.xml【 MobileMapper.xml 】和【 BrandMapper.xml 】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;mapper namespace="mobileMapper"&gt; &lt;select id="getAll" parameterType="PageHelper" resultType="map"&gt; SELECT m.mobileId, b.brandName, b.`desc`, m.type, m.os, m.cpu, m.ramSize, m.diskSize FROM mobile AS m INNER JOIN brand AS b ON m.brandId = b.brandId &lt;trim prefix="WHERE" prefixOverrides="and|or"&gt; &lt;if test="keyStr != null"&gt; stuName like concat('%',#&#123;keyStr&#125;,'%') &lt;/if&gt; &lt;/trim&gt; LIMIT #&#123;currentNo&#125;,#&#123;pageSize&#125; &lt;/select&gt; &lt;select id="getCount" resultType="integer"&gt; SELECT COUNT( 1 ) FROM mobile AS m INNER JOIN brand AS b ON m.brandId = b.brandId &lt;/select&gt; &lt;delete id="delBatch" parameterType="integer"&gt; DELETE FROM mobile WHERE mobileId IN &lt;foreach item="ids" collection="array" open="(" close=")" separator=","&gt; #&#123;ids&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;update id="modifyOne" parameterType="MobileEntity"&gt; UPDATE mobile &lt;trim prefix="SET" suffix="WHERE mobileId = #&#123;mobileId&#125;" suffixOverrides=","&gt; &lt;if test="brandId != null"&gt; brandId = #&#123;brandId&#125;, &lt;/if&gt; &lt;if test="type != null"&gt; type = #&#123;type&#125;, &lt;/if&gt; &lt;if test="os != null"&gt; os = #&#123;os&#125;, &lt;/if&gt; &lt;if test="cpu != null"&gt; cpu = #&#123;cpu&#125;, &lt;/if&gt; &lt;if test="ramSize != null"&gt; ramSize = #&#123;ramSize&#125;, &lt;/if&gt; &lt;if test="diskSize != null"&gt; diskSize = #&#123;diskSize&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/update&gt; &lt;insert id="saveOne" parameterType="MobileEntity"&gt; INSERT INTO mobile ( `brandId`, `type`, `os`, `cpu`, `ramSize`, `diskSize` ) VALUES (#&#123;brandId&#125;,#&#123;type&#125;,#&#123;os&#125;,#&#123;cpu&#125;,#&#123;ramSize&#125;,#&#123;diskSize&#125;) &lt;/insert&gt;&lt;/mapper&gt; 1234567891011&lt;mapper namespace="brandMapper"&gt; &lt;select id="getAll" resultType="map"&gt; SELECT brandId, brandName FROM brand &lt;/select&gt;&lt;/mapper&gt; 3) 建立Dao实现【 MobileDaoImpl 】和【 BrandDaoImpl 】12345678910111213141516171819202122232425262728293031@Repository("mobileDao")public class MobileDaoImpl implements IMobileDao &#123; @Resource(name = "sqlSessionTemplate") private SqlSessionTemplate sqlTemplate; @Override public List&lt;HashMap&gt; queryAll(PageHelper page) &#123; return sqlTemplate.selectList("mobileMapper.getAll", page); &#125; @Override public int queryCount() &#123; return Integer.parseInt(sqlTemplate.selectOne("mobileMapper.getCount") + ""); &#125; @Override public int delBatch(Integer[] idArr) &#123; return sqlTemplate.delete("mobileMapper.delBatch", idArr); &#125; @Override public int modifyOne(MobileEntity mobile) &#123; return sqlTemplate.update("mobileMapper.modifyOne", mobile); &#125; @Override public int saveOne(MobileEntity mobile) &#123; return sqlTemplate.update("mobileMapper.saveOne", mobile); &#125;&#125; 12345678910@Repository("brandDao")public class BrandDaoImpl implements IBrandDao &#123; @Resource(name = "sqlSessionTemplate") private SqlSessionTemplate sqlTemplate; @Override public List&lt;HashMap&gt; queryAll() &#123; return sqlTemplate.selectList("brandMapper.getAll"); &#125;&#125; @Repository(“mobileDao”) + @Resource(name = “sqlSessionTemplate”) 注解，它会被自动解析为123&lt;bean id="mobileDao" class="com.fan.dao.impl.MobileDaoImpl"&gt; &lt;property name="sqlTemplate" ref="sqlSessionTemplate"/&gt;&lt;/bean&gt; 4) 建立Servive层【 MobileBiz 】和【 BrandBiz 】12345678910111213141516171819202122232425@Service("mobileBiz")public class MobileBiz &#123; @Resource(name = "mobileDao") private IMobileDao mobileDao; public List&lt;HashMap&gt; queryAll(PageHelper page) &#123; return mobileDao.queryAll(page); &#125; public int queryCount() &#123; return mobileDao.queryCount(); &#125; public int delBatch(Integer[] idArr) &#123; return mobileDao.delBatch(idArr); &#125; public int modifyOne(MobileEntity mobile) &#123; return mobileDao.modifyOne(mobile); &#125; public int saveOne(MobileEntity mobile) &#123; return mobileDao.saveOne(mobile); &#125;&#125; 123456789@Service("brandBiz")public class BrandBiz &#123; @Resource(name = "brandDao") private IBrandDao brandDao; public List&lt;HashMap&gt; queryAll() &#123; return brandDao.queryAll(); &#125;&#125; @Service(“mobileBiz”) + @Resource(name = “mobileDao”) 注解，它会被自动解析为123&lt;bean id="mobileBiz" class="com.fan.service.MobileBiz"&gt; &lt;property name="mobileDao" ref="mobileDao"/&gt;&lt;/bean&gt; 5) 创建分页工具类、API实体类和输出类 【 PageHelper 】、【 ApiEntity 】和【 ApiHelper 】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Getter@Setterpublic class PageHelper &#123; /** * 当前页码 */ private int pageNo; private int currentNo; /** * 每页显示条数 */ private int pageSize; /** * 数据总数 */ private int dataCount; /** * 总页码 */ private int pageCount; /** * 搜索关键字 */ private String keyStr; public PageHelper() &#123; &#125; public PageHelper(int pageNo, int pageSize, int dataCount, String keyStr) &#123; this.pageSize = pageSize; this.dataCount = dataCount; this.pageCount = ((dataCount % pageSize) == 0) ? (dataCount / pageSize) : ((dataCount / pageSize) + 1); if ((0 &gt;= pageNo) || (pageCount &lt; pageNo)) &#123; this.pageNo = 1; &#125; else &#123; this.currentNo = (pageNo - 1) * pageSize; &#125; if ("".equals(keyStr) || (null == keyStr)) &#123; this.keyStr = null; &#125; else &#123; this.keyStr = keyStr; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940@Datapublic class ApiEntity &#123; /** * 当前返回数据的状态码 */ private Integer code; /** * 当前返回数据的提示 */ private String msg; /** * 当前返回数据的条数 */ private Integer total; /** * 总共条数 */ private Integer count; /** * 当前返回的数据 */ private Object data; public ApiEntity(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ApiEntity(Integer code, String msg, Integer total, Integer count,Object data) &#123; this.code = code; this.msg = msg; this.total = total; this.count = count; this.data = data; &#125;&#125; 123456789101112131415161718192021222324252627282930public class ApiHelper &#123; /** * desc: 适用于输出查询的数据 * * @param response HttpServletResponse对象 * @param list 任何类型的list数据 * @param count 数据总条数 * @param row 增删改后返回的受影响行数 * @return out对象 * @auther CR7 * @date 2018/12/29 13:31 */ public static void out(HttpServletResponse response, List&lt;?&gt; list, Integer count, Integer row) throws Exception &#123; PrintWriter out = response.getWriter(); response.setCharacterEncoding("UTF-8"); response.setContentType("application/json;charset=UTF-8"); response.setHeader("Access-Control-Allow-Origin", "*"); ApiEntity api; if (null != list) &#123; api = new ApiEntity(200, "SUCCESS", list.size(), count, JSON.toJSON(list)); &#125; else if (row &gt; 0) &#123; api = new ApiEntity(200, "SUCCESS"); &#125; else &#123; api = new ApiEntity(400, "ERROR"); &#125; out.println(JSON.toJSONString(api)); out.flush(); out.close(); &#125;&#125; 6) 创建控制器【 MobileController 】和【 BrandController 】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Controllerpublic class MobileController &#123; @Autowired private MobileBiz mobileBiz; /** * desc: 分页查询全部手机信息 * * @param response 对象 * @param page 起始页码 * @param limit 页面大小 * @return void * @auther CR7 * @date 2018/12/29 12:35 */ @RequestMapping("/getMobile") public void queryAll(HttpServletResponse response, @RequestParam String page, @RequestParam String limit) throws Exception &#123; int dataCount = mobileBiz.queryCount(); List&lt;HashMap&gt; list = mobileBiz.queryAll(new PageHelper(Integer.parseInt(page), Integer.parseInt(limit), dataCount, null)); ApiHelper.out(response, list, dataCount, 0); &#125; /** * desc: 删除手机信息 * * @param response 对象 * @param id * @return void * @auther CR7 * @date 2018/12/29 12:45 */ @RequestMapping("/delBatch") public void delOne(HttpServletResponse response, @RequestParam Integer[] id) throws Exception &#123; ApiHelper.out(response, null, 0, mobileBiz.delBatch(id)); &#125; /** * desc: 修改手机信息 * * @param response 对象 * @param mobile MobileEntity * @return void * @auther CR7 * @date 2018/12/29 12:45 */ @RequestMapping("/modifyOne") public void modifyOne(HttpServletResponse response, MobileEntity mobile) throws Exception &#123; ApiHelper.out(response, null, 0, mobileBiz.modifyOne(mobile)); &#125; /** * desc: 添加手机信息 * * @param response 对象 * @param mobile MobileEntity * @return void * @auther CR7 * @date 2018/12/29 12:45 */ @RequestMapping("/saveOne") public void saveOne(HttpServletResponse response, MobileEntity mobile) throws Exception &#123; ApiHelper.out(response, null, 0, mobileBiz.saveOne(mobile)); &#125;&#125; 12345678910@Controllerpublic class BrandController &#123; @Autowired private BrandBiz brandBiz; @RequestMapping("/getBrand") public void getBrand(HttpServletResponse response) throws Exception &#123; ApiHelper.out(response, brandBiz.queryAll(), 0, 0); &#125;&#125; 7) 使用PostMan测试API 查询全部品牌信息 http://localhost:81/getBrand 分页查询手机信息 http://localhost:81/getMobile?page=1&amp;limit=2 储存手机信息 http://localhost:81/saveOne?brandId=1&amp;type=测试&amp;os=1&amp;cpu=1&amp;ramSize=1&amp;diskSize=1 修改手机信息 http://localhost:81/modifyOne?brandId=1&amp;type=1&amp;os=1&amp;cpu=1&amp;ramSize=1&amp;diskSize=1&amp;mobileId=19 批量删除手机信息 http://localhost:81/delBatch?id=18&amp;id=19 8) 前端界面 全部 新增 修改 删除 9) 完整项目]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM 非注解版整合]]></title>
    <url>%2Fposts%2F9816%2F</url>
    <content type="text"><![CDATA[一、SSM框架 SSM框架（Spring + Spring Mvc + Mybatis）在实际的企业级开发中日益取代（Spring + Struts2 + Hibernate），成为了目前使用最多的框架，也是Java程序员必须掌握的生存技巧。 Spring 1) Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，主要目的是简化Java开发 2) Spring的优势 低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） Spring 框架中包括了J2EE三层的每一层的解决方案 3) Spring作用 Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系 Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制 Spring 能非常简单的帮我们管理数据库事务 Spring 提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问 Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建 Spring 能方便的与Java EE（如Java Mail、任务调度）整合 4) 查看更多1 查看更多2 Spring Mvc My previous article Mybatis My previous article 二、SSM搭建环境 工具 Windows 10 IntelliJ IDEA 2018.3.3 Navicat Premium 12 环境 Jdk 1.8 MySQL 5.7 Apache-Tomcat 9 Apache-Maven 3.6.0 技术 Spring 4.3.9.RELEASE Mybatis 3.2.8 Druid 1.1.10 三、使用 IDEA+Maven 构建 SSM 项目1、创建Maven webapp 项目，勾选【 Create from archetype 】选择【 maven-archetype-webapp 】，千万别选成了【 cocoon-22-archetype-webapp 】2、点击Next，分别填写好 GroupId：对应java包结构下的目录结构 如com.cheery ArtifactId：实际的项目名称 3、这一步默认就好，点击Next4、指定好项目名称和存放路径，点击Finish5、进入项目后查看控制台的右边，点击【 Enable Auto-Import 】，等待进程加载完成6、默认生成的目录架构 src目录下有mian和test两个目录 mian目录下有java、resources、webapp java目录下存放java源代码 resources目录下存放配置文件 webapp目录下存放web资源 target目录下有classes文件夹，存放编译过后的文件 7、编写配置文件1) pom.xml 该文件用于管理：源代码、配置文件、开发者的信息和角色、问题追踪系统、组织信息、项目授权、项目的url、项目的依赖关系…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fan&lt;/groupId&gt; &lt;artifactId&gt;EMS&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;EMS Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- jdk版本号 --&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.9.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- No1 Spring --&gt; &lt;!-- Spring core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Dao --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Mvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- No2 Mybatis、Mysql驱动、连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis-spring整合包 --&gt; &lt;!-- mybatis的3.4.0及以上版本用mybatis-spring1.3.0及以上版本 mybatis的3.4.0以下版本用mybatis-spring1.3.0以下版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- No3 日志 --&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- slf4j-nop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-logging --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- aopalliance --&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- asm --&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring4&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- cglib --&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;EMS&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 2) web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;!-- 配置统一错误页面 --&gt; &lt;error-page&gt; &lt;error-code&gt;400&lt;/error-code&gt; &lt;location&gt;/400.html&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/500.html&lt;/location&gt; &lt;/error-page&gt; &lt;!-- druid连接池 --&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 解决乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置拦截SpringMvc核心拦截器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 设置springmvc配置文件位置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/mvc/*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置该启动器开启的顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 加载log4j --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/Spring-core.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;view/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 3) log4j.properties 日志12345log4j.rootLogger=error, Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%nlog4j.logger.org.apache=INFO 4) druid.properties 连接池123456789101112131415161718driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/public?useUnicode=true&amp;characterEncoding=utf8theUser=rootpassword=rootfilters=statinitialSize=6maxActive=20minIdle=3maxWait=60000validationQuery=SELECT 'x'testWhileIdle=truetestOnBorrow=falsetestOnReturn=falsemaxPoolPreparedStatementPerConnectionSize=20removeAbandoned=trueremoveAbandonedTimeout=60timeBetweenEvictionRunsMillis=10000minEvictableIdleTimeMillis=30000 5) SpringMvc-core.xml springmvc配置123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="order" value="0"/&gt; &lt;property name="prefix" value="/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;property name="contentType" value="text/html;charset=UTF-8"/&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.InternalResourceView"/&gt; &lt;/bean&gt; &lt;!-- 配置Handler映射器 --&gt; &lt;bean id="simpleUrlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/login.do"&gt;userController&lt;/prop&gt; &lt;prop key="/register.do"&gt;userController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 方法名称解析器 --&gt; &lt;bean id="springMethodNameResolver" class="org.springframework.web.servlet.mvc.multiaction.PropertiesMethodNameResolver"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- 对用控制器中的login方法 --&gt; &lt;prop key="/login.do"&gt;login&lt;/prop&gt; &lt;!-- 对用控制器中的register方法 --&gt; &lt;prop key="/register.do"&gt;register&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 将映射器和解析器绑定 --&gt; &lt;bean id="userController" class="com.fan.controllers.UserController"&gt; &lt;property name="methodNameResolver" ref="springMethodNameResolver"/&gt; &lt;!-- 注入Service --&gt; &lt;property name="userServ" ref="userServ"/&gt; &lt;/bean&gt;&lt;/beans&gt; 6) SpringMvc-dao.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt; &lt;bean id="userDao" class="com.fan.dao.impl.UserDaoImpl"&gt; &lt;!-- 注入sqlSessionTemplate --&gt; &lt;property name="sqlSessionTemplate" ref="sqlSessionTemplate"/&gt; &lt;/bean&gt;&lt;/beans&gt; 7) SpringMvc-service.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt; &lt;!-- 引入Spring-dao.xml --&gt; &lt;import resource="classpath:configs/mvc/Spring-dao.xml"/&gt; &lt;bean id="userServ" class="com.fan.service.userServ"&gt; &lt;property name="userDao" ref="userDao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 8) mybatis-core.xml123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 启用二级缓存 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- 使用getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;/settings&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.fan.pojos.UserEntity" alias="UserEntity"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 9) Spring-core.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"&gt; &lt;!-- 导入所有关于dao、service、springmvc的配置文件 --&gt; &lt;import resource="classpath:configs/mvc/*.xml"/&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1、加载druid.properties连接池属性 --&gt; &lt;context:property-placeholder location="classpath:configs/druid.properties"/&gt; &lt;!-- 2、数据库Druid连接池 --&gt; &lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;theUser&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;property name="filters" value="$&#123;filters&#125;"/&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;"/&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;"/&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;"/&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;"/&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;"/&gt; &lt;/bean&gt; &lt;!-- 3、配置sessionFactory对象 --&gt; &lt;bean id="sessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt; &lt;!-- 关联mybatis核心配置文件 --&gt; &lt;property name="configLocation" value="classpath:configs/mybatis-core.xml"/&gt; &lt;!-- 扫描mapper配置文件 --&gt; &lt;property name="mapperLocations" value="classpath:configs/mappers/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 4、提供执行CURD的sqlSessionTemplate对象注入到dao层 --&gt; &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg name="sqlSessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 事务配置 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt; &lt;/bean&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="del*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="add*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="REQUIRED"/&gt; &lt;tx:method name="get*" propagation="REQUIRED"/&gt; &lt;tx:method name="*" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切入点 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.fan.service.*.* (..))" id="txPointCut"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 四、案例 【 登陆 – 注册 】1) 创建实体【 UserEntity 】1234567@Datapublic class UserEntity implements Serializable &#123; private static final long serialVersionUID = 6309209295463171744L; private Integer id; private String username; private String password;&#125; 2) 创建Dao接口【 IUserDao 】1234public interface IUserDao &#123; boolean userLogin(String username, String password); boolean userRegister(UserEntity user);&#125; 3) 创建Mapper.xml【 UserMapper.xml 】1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="userMapper"&gt; &lt;select id="login" parameterType="map" resultType="UserEntity"&gt; SELECT * FROM test WHERE username = #&#123;username&#125; AND password = #&#123;password&#125; &lt;/select&gt; &lt;insert id="saveOne" parameterType="UserEntity"&gt; INSERT INTO test(`username`,`password`) VALUES(#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 3) 建立Dao实现【 UserDaoImpl 】1234567891011121314151617181920@Setterpublic class UserDaoImpl implements IUserDao &#123; private SqlSessionTemplate sqlSessionTemplate; @Override public boolean userLogin(String username, String password) &#123; Map map = new HashMap(); map.put("username",username); map.put("password",password); UserEntity user = sqlSessionTemplate.selectOne("userMapper.login",map); if(null != user)&#123; return true; &#125;else&#123; return false; &#125; &#125; @Override public boolean userRegister(UserEntity user) &#123; return sqlSessionTemplate.insert("userMapper.saveOne",user) &gt; 0; &#125;&#125; 4) 建立Servive层【 UserDaoImpl 】12345678910@Setterpublic class UserBiz &#123; private IUserDao userDao; public Boolean userLogin(String username, String password) &#123; return userDao.userLogin(username,password); &#125; public Boolean userRegister(UserEntity user) &#123; return userDao.userRegister(user); &#125;&#125; 5) 创建控制器【 UserController 】123456789101112131415161718192021222324252627@Setterpublic class UserController extends MultiActionController &#123; private userServ userServ; public ModelAndView login(HttpServletRequest request, HttpServletResponse response) &#123; String u = request.getParameter("username"); String p = request.getParameter("password"); ModelAndView mav = null; HttpSession session = request.getSession(); if(userServ.userLogin(u,p))&#123; session.setAttribute("message", u + " say hello SpringMVC !!!"); mav = new ModelAndView("message"); &#125; else&#123; mav = new ModelAndView("redirect:login.jsp"); &#125; return mav; &#125; public ModelAndView register(HttpServletRequest request, HttpServletResponse response,UserEntity user) &#123; System.out.println(user.getUsername() + "--" + user.getPassword()); ModelAndView mav = null; if (userServ.userRegister(user)) &#123; mav = new ModelAndView("redirect:login.jsp"); &#125; else &#123; mav = new ModelAndView("redirect:register.jsp"); &#125; return mav; &#125;&#125; 6) 发送请求登陆 成功跳转至message.jsp页面 http://localhost:81/root/login 注册 成功跳转至login.jsp页面 http://localhost:81/root/register 7) 完整项目]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc 基于注解开发]]></title>
    <url>%2Fposts%2F7593%2F</url>
    <content type="text"><![CDATA[一、常用注解 @Component 在类定义之前添加@Component注解，它会被spring容器识别，并转为bean @Repository 用于对持久层进行注解 @Service 用于对业务逻辑层进行注解 @Controller 用于对控制层进行注解 @RequestMapping 用于处理请求地址映射的注解，可用在类和方法上。如果应用在类上表示所有请求的方法都以改地址作为父路径 常用的属性 1) value method value：指定请求的实际路径 如RequestMapping(value=”/login”)，访问127.0.0.1:80/login即可 method：指定请求的method类型，POST、GET、HEAD、PUT… 如RequestMapping(value = “/login”, method = RequestMethod.GET) 2) consumes produces consumes：指定处理请求的提交内容类型（Content-Type），例如application/json、text/html produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 3) params headers params：指定request中必须包含某些参数值时，才让该方法处理 headers：指定request中必须包含某些指定的header值，才能让该方法处理请求 @Autowired 和 @Resource 都是做bean的注入时使用，其实@Resource并不是Spring的注解，但是Spring支持该注解的注入 1) Autowired 是按照类型装配依赖对象的，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false 12345678910public class UserController &#123; /* 以下两种注入效果一致 */ @Autowired private UserSer userSer; @Autowired public void setUserSer(UserSer userSer)&#123; this.userSer = userSer; &#125;&#125; 2) Resource 是按照名称装配依赖对象的，@Resource有两个重要的属性：name和type，Spring将@Resource注解的name属性解析为bean的名字、type属性则解析为bean的类型 12345678910public class UserController &#123; /* 以下两种注入效果一致 */ @Resource(name="userSer") private UserSer userSer; @Resource(name="userSer") public void setUserSer(UserSer userSer)&#123; this.userSer = userSer; &#125;&#125; @Resource装配顺序 ① 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 ② 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 ③ 如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常 ④ 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配 @PathVariable 用于映射URL绑定的占位符 可以在@RequestMapping注解中用{}来表明它的变量部分123456789@Controller public class TestController &#123; @RequestMapping(value="/user/&#123;userId&#125;/roles/&#123;roleId&#125;",method = RequestMethod.GET) public String getLogin(@PathVariable("userId") String userId,@PathVariable("roleId") String roleId)&#123; System.out.println("User Id : " + userId); System.out.println("Role Id : " + roleId); return "hello"; &#125;&#125; @RequestParam 用于获取请求的参数，类似一种是request.getParameter(“xxx”)取值方式 常用的属性 1) defaultValue 表示设置的默认值 2) required 表示是否传入的参数 true/false 3) value 表示接收传入的参数类型 @ResponseBody 该方法返回结果直接写入 HTTP response body 中，不会做页面跳转 转载修改至 https://www.cnblogs.com/leskang/p/5445698.html 二、代码案例1、编写Dao层实现类1234567@Repository("userDao")public class UserDaoImpl implements IUserDao &#123; @Override public Boolean userLogin(String username, String pwd) &#123;&#125; // 省略具体实现 @Override public Boolean userRegister(UserEntity user) &#123;&#125; // 省略具体实现&#125; 2、编写Service层1234567891011@Service("userSer")public class UserSer &#123; @Autowired private UserDaoImpl userDao; public Boolean userLogin(String username, String pwd) &#123; return userDao.userLogin(username,pwd); &#125; public Boolean userRegister(UserEntity user) &#123; return userDao.userRegister(user); &#125;&#125; 3、编写方法控制类1234567891011121314151617181920212223242526272829@Controller@RequestMapping("root") //该类的所有方法前面必须加上root 如root/loginpublic class UserController &#123; @Autowired private HttpSession session; @Autowired private UserSer userSer; @RequestMapping(value = "/login", method = RequestMethod.GET) public ModelAndView login(@RequestParam String username, @RequestParam String password) throws Exception &#123; ModelAndView mav = null; if (userSer.userLogin(username, password)) &#123; session.setAttribute("message", username + " say hello SpringMVC !!!"); mav = new ModelAndView("message"); &#125; else &#123; mav = new ModelAndView("redirect:/login.jsp"); &#125; return mav; &#125; @RequestMapping(value = "register", method = RequestMethod.POST) public ModelAndView register(UserEntity user) throws Exception &#123; ModelAndView mav = null; if (userSer.userRegister(user)) &#123; mav = new ModelAndView("redirect:/login.jsp"); &#125; else &#123; mav = new ModelAndView("redirect:/register.jsp"); &#125; return mav; &#125;&#125; 4、编写SpringMvc配置文件如【 SpringMvc-core.xml 】1234567&lt;!-- 配置自动扫描类中的注解 --&gt;&lt;context:component-scan base-package="com.fan.controllers,com.fan.dao.Impl,com.fan.service"/&gt;&lt;!-- 视图解析器 --&gt;&lt;bean id="irvResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 必须开启扫描各个类中配置的注解 5、发送请求登陆 成功跳转至message.jsp页面 http://localhost:81/root/login 注册 成功跳转至login.jsp页面 http://localhost:81/root/register]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面试题整理 (基础篇)]]></title>
    <url>%2Fposts%2F6292%2F</url>
    <content type="text"><![CDATA[一、面向对是什么？有哪些特征？ https://www.cnblogs.com/wmyskxz/p/9016611.html 面向对象是一种思想，世间万物都可以看做一个对象 优点 代码开发模块化，更易维护和修改 代码复用性强 增强代码的可靠性和灵活性 增加代码的可读性 特征 封装 概念：封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能 特点：使用操作更加的安全和简化 继承 继承是面向对象实现代码复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员 优点：容易实现和扩展 缺点：1、继承是一种强耦合关系，父类变子类也必须变化 2、继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的 多态 概念：多态就是同一个行为具有多个不同表现形式或形态的能力 条件：1、继承 2、重写 3、向上转型 特点：提高了代码的维护性和扩展性 抽象 概念：抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式 二、什么是Java JVM？ Java虚拟机是一个可以执行Java字节码的虚拟机进程，Java源文件被编译成能被Java虚拟机执行的字节码文件。 三、&amp;和&amp;&amp;的区别Java中&amp;和&amp;&amp;都是表示与的逻辑运算符，都表示逻辑运输符and，当两边的表达式都为true的时候，整个运算结果才为true，否则为false &amp;可以用作位运算符，当&amp;两边的表达式不是Boolean类型的时候，&amp;表示按位操作 &amp;&amp;的短路功能，当第一个表达式的值为false的时候，则不再计算第二个表达式；&amp;则两个表达式都执行 四、char变量能不能储存一个中文汉字？java采用unicode，2个字节（16位）来表示一个字符，所以可以储存一个中文汉字 五、error和exception三、JDK、JRE、JVM关系是什么？ JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率 JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持 四、如何创建一个对象？ 使用new关键字：会显示的调用构造函数 使用clone方法：是在内存上对已有的对象的拷贝，不会调用构造函数 反射机制：会显示的调用构造函数 反序列化：是从文件中还原类的对象，不会调用构造函数 五、clone()与new的区别 new和clone()都能创建对象 clone()不会调用构造方法；new会调用构造方法 clone()能快速的创建一个已有的对象的副本，即创建对象并且将已有对象中所有属性值克隆 new只能在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值 PS: 使用clone()类必须实现java.lang.Cloneable接口并重写Object类的clone()方法，如果没有实现Cloneable()接口将会抛出CloneNotSupportedException异常 默认的Object.clone()方法是浅拷贝，创建好对象的副本然后通过“赋值”拷贝内容，如果类包含引用类型变量，那么原始对象和克隆对象的引用将指向相同的引用内容 六、什么是浅拷贝和深拷贝？ “浅拷贝”：默认的Object.clone()方法,对于引用类型成员变量拷贝只是拷贝“值”即地址,没有在堆中开辟新的内存空间 “深拷贝”：重写clone()方法，对于引用类型成员变量，重新在堆中开辟新的内存空间 七、方法重载和方法重写的关系 重载(Overload) 是为了让类以统一的方式处理不同类型数据的一种手段 一个类中有多个同名函数，但是具有不同的参数个数和类型 重载是多态性的一种表现 重载方法的规则 必须有不同的参数列表 可以有不同的返回类型，只要参数列表不同就可以了 可以有不同的访问修饰符 可以抛出不同类型的异常 重写(Override) 父类与子类之间的多态性，对父类函数进行重新定义 与父类某个方法完全相同，只是方法体不同 如需要父类的原有方法，使用super关键字 子类函数的访问修饰符权限不能小于父类函数 重写方法的规则 子类方法的参数列表必须完全与被重写的方法的相同 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） 重写方法一定不能抛出新的检查异常或者比被重写方法申明更宽泛的检查型异常 八、Java构造方法能否被重写和重载？ 构造函数能被重载，例如在同一个类中存在多个不同参数的的构造函数 构造函数不能被重写，例如在子类中不可能存在与父类类名一致的函数 九、实现多线程的两种方法 继承Thread类，重写它的run()方法 实现Runnable接口，重写Runable接口中的run()方法 十、是否可以继承String类，为什么？ 因为String类是final类，final修饰的类不能被继承 十一、Java抽象类和接口的异同点 相同点 不能被实例化 能将抽象类和接口作为引用类型 某个类继承了抽象类或实现了接口，就必须对其父类的抽象方法全部实现，除非该类也是抽象类 差异点 抽象类中能定义构造器;而接口中不能定义构造器 抽象类中可以有抽象方法和普通方法;而接口中的方法全都是抽象方法 抽象类中的访问修饰符可以是private、默认、protected、public;而接口中的访问修饰符全都是public 抽象类中可以定义成员变量;而接口中的成员变量会自动加上public final转变为常量 抽象类中可以有静态方法;而接口中不可以有静态方法 抽象类中不一定要有抽象方法，而有抽象方法的类一定是抽象类 一个类只能继承一个抽象类可以实现多个接口 十二、Java抽象类和接口的应用场景 https://www.cnblogs.com/wmyskxz/p/9016611.html 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类 如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类 十三、final和static的用法 http://www.cnblogs.com/dolphin0520/p/3799052.html final final修饰的类不能被继承 final修饰的方法不能被重写 final修饰的变量为常量它的值不能被修改 static：方便在没有创建对象的情况下来进行调用（方法/变量） static表示“全局”或者“静态”的意思，能修饰成员变量和成员方法，也可以形成静态static代码块 static变量 静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化 非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响 static方法 静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的 静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用 static代码块 static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次 十四、Java 中的值传递和引用传递 值传递是指对象被值传递，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象 引用传递是指对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用值会受到影响 十五、i++ 与 ++i 到底有什么不同？ https://www.cnblogs.com/wmyskxz/p/9016611.html 不管是前置 ++，还是后置 ++，都是先将变量的值加1，然后才继续计算的 前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的 后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加1，然后使用那个临时变量进行运算 十六、类什么时候被初始化？ 创建类的实例，也就是使用new操作符 访问某个类或接口的静态变量，或者对该静态变量赋值 访问类的静态方法 反射Class.forName 初始化类的子类(会先初始化该类的父类) JVM启动时标明的启动类，即文件名和类名相同的那个类 十七、类的初始化步骤 如果该类还没有被加载和连接，那么先进行加载和连接 假如这个类存在直接的父类，并且该类还没被初始化，那就先初始化直接的父类[ 不适合接口 ] 假如类中存在初始化语句[ 如static变量和static块 ]，那么就依次执行这些初始化语句 十八、获得一个类有哪些方式？ 类型.class 对象.getclass Class.forName() 十九、父类与子类之间的调用顺序1、父类静态代码块2、子类静态代码块3、父类构造方法4、子类构造方法5、重写父类的方法 二十、Java中==和eqauls()的区别 ==和eqauls()的最大的区别就是一个是运算符一个是方法 == 如果比较的对象是基本数据类型，则比较的是数值是否相等 如果比较的是引用数据类型，则比较的是对象的地址值是否相等 eqauls() 用来比较方法两个对象的内容是否相等； 不能用于基本数据类型的变量，如果没有对eqauls方法进行重写，则比较的是引用类型的变量所指向的对象的地址]]></content>
      <tags>
        <tag>原创</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面试题整理 (集合框架篇)]]></title>
    <url>%2Fposts%2F5392%2F</url>
    <content type="text"><![CDATA[一、起步集合类都位于java.util包下，Java 集合框架主要包括两种类型的容器，一种是集合（Collection）,存储一个元素集合;另一种是图（Map）,存储键/值对映射。支持序列化 二、Collection接口1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125; 查看源码发现Collection是一个接口类，其继承了java迭代接口Iterable 有三个主要的子接口List、Set 和 Queue，记住Map不是Collection的子接口!! 存储特点允许重复的对象 常用的方法 三、List接口1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; 查看源码发现List是一个接口类，其继承了Collection接口，它可以定义一个允许重复的有序集合 List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引 List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 实现List接口的集合主要有： (1) ArrayList 1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable&#123;&#125; ArrayList继承于AbstractList，实现了List、RandomAccess、Cloneable、Serializable接口 ArrayList是一个动态数组，也是我们最常用的集合 它允许任何符合规则的元素插入甚至包括null 每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小，但是数组大小是动态的 总的特点:基于数组实现，非线程安全，便于索引，查询效率高，但不便于插入和删除 (2) LinkedList 1public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable&#123;&#125; LinkedList继承于AbstractSequentialList，实现了List，Deque，Cloneable，Serializable接口 LinkedList是一个双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低 它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部进行操作 有个重要的内部类Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 总的特点:基于链表实现，链表内存是散乱的，每一个元素本身内存地址的同时还存储下一个的地址，链表增删快，查找慢 (3) Vector 1public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable&#123;&#125; Vector继承于AbstractList，实现了List，RandomAccess，Cloneable，Serializable接口 与ArrayList相似，但是Vector是同步的 Vector是线程安全的动态数组 总的特点:基于数组实现，线程安全的，效率低 四、Map接口1public interface Map&lt;K,V&gt; &#123;&#125; 查看源码发现Map是一个接口类，但是它不继承或者实现任何类或接口 Map与List、Set接口不同，它是由一系列键值对组成的集合 提供了key到Value的映射 Map中它保证了key与value之间的一一对应关系 它不能存在相同的key值，而value值可以相同 实现Map接口的集合主要有： (1) HashMap 1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; HashMap继承于AbstractMap，实现了Map，Cloneable，Serializable接口 HashMap 是一个散列表，它存储的内容是键值对(key-value)映射 HashMap 的实现不是同步的，这意味着它不是线程安全的 HashMap中的映射不是有序的 总的特点:基于hash表的Map接口实现，非线程安全的，效率高，key、value都可以为null (2) HashTable 1public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; HashTable继承于Dictionary，实现了Map，Cloneable，Serializable接口 HashTable 是一个散列表，它存储的内容是键值对(key-value)映射 HashTable的实现是同步的，这意味着它是线程安全的 HashTable中的映射不是有序的 总的特点:基于hash表的Map接口实现，线程安全的，效率低，key、value都不可以为null (3) LinkedHashMap 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; LinkedHashMap继承于HashMap，实现了 Map接口 LinkedHashMap是一个HashMap的子类，它保留插入的顺序 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap LinkedHashMap是Map接口哈希表和链接列的实现，具有可预知的迭代顺序 总的特点:基于HashMap，保存了记录的插入顺序，非线程安全的，key、value都可以为null 五、Set接口1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; 查看源码发现Set是一个接口类，其继承了Collection接口 Set中的元素实现了不重复，有点象集合的概念 由于Set接口的特殊性，所有传入Set集合中的元素都必须不同 最多允许有一个null元素对象 无序，不允许有重复的元素 虽然Set中元素没有顺序，但是元素在set中的位置是有由该元素的HashCode决定的，其具体位置其实是固定的 实现Set接口的集合主要有： (1) HashSet 1public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable&#123;&#125; HashSet继承于AbstractSet，实现了Set，Cloneable，Serializable接口 HashSet是一个没有重复元素的集合，它是由HashMap实现的，不保证元素的顺序 HashSet允许使用null元素，但是非同步的 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能 HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象 总的特点:基于HashMap，不允许集合中有重复的值，使用该方式时需要重写equals()和hashCode()方法 (2) LinkedHashSet 1public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable &#123;&#125; LinkedHashSet继承于HashSet，实现了Set，Cloneable，Serializable接口 LinkedHashSet底层是基于LinkedHashMap来实现的，有序非同步 LinkedHashSet集合是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序 LinkedHashSet将会以元素的添加顺序访问集合的元素 总的特点:基于HashMap，不允许集合中有重复的值，保存了记录的插入顺序 (2) TreeSet 1public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable &#123;&#125; TreeSet继承于AbstractSet，实现了NavigableSet，Cloneable，Serializable接口 TreeSet是一个有序集合 TreeSet可以确保集合元素处于排序状态 TreeSet支持两种排序方式，自然排序和定制排序 TreeSet通过compare或者comparaeTo函数来判断元素是否相等 总的特点:基于TreeMap，非线程安全，非同步的]]></content>
      <tags>
        <tag>原创</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc 多方法控制器和拦截器]]></title>
    <url>%2Fposts%2F4392%2F</url>
    <content type="text"><![CDATA[一、MultiActionController后端控制器MultiActionController类用于在单个控制器中分别映射多个URL到对应的方法，这样能减少很多类，系统的性能也会得到一定的提升。 1、编写多方法控制类12345678910111213141516171819202122232425public class UserController extends MultiActionController &#123; public ModelAndView login(HttpServletRequest request, HttpServletResponse response) &#123; String u = request.getParameter("username"); String p = request.getParameter("password"); IUserDao userDao = new UserDaoImpl(); ModelAndView mav = null; if (userDao.userLogin(u, p)) &#123; mav = new ModelAndView("message"); mav.addObject("message", u + " say hello SpringMVC !!!"); &#125; else &#123; mav = new ModelAndView("redirect:login.jsp"); &#125; return mav; &#125; public ModelAndView register(HttpServletRequest request, HttpServletResponse response, UsertEntity user) &#123; IUserDao userDao = new UserDaoImpl(); ModelAndView mav = null; if (userDao.userRegister(user)) &#123; mav = new ModelAndView("redirect:login.jsp"); &#125; else &#123; mav = new ModelAndView("redirect:register.jsp"); &#125; return mav; &#125;&#125; 该类必须继承MultiActionController 2、编写SpringMvc配置文件如【 SpringMvc-core.xml 】以下两种配置达成的效果一致，但是不能共存，请结合应用场景使用 BeanNameUrlHandlerMapping 123&lt;!-- 映射处理器BeanNameUrlHandlerMapping --&gt;&lt;bean name="/login.php" class="com.fan.controllers.UserController"/&gt;&lt;bean name="/register.php" class="com.fan.controllers.UserController"/&gt; SimpleUrlHandlerMapping 1234567891011121314151617181920&lt;bean id="simpleUrlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/login.php"&gt;userController&lt;/prop&gt; &lt;prop key="/register.php"&gt;userController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="springMethodNameResolver" class="org.springframework.web.servlet.mvc.multiaction.PropertiesMethodNameResolver"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/login.php"&gt;login&lt;/prop&gt; &lt;!-- 对用控制器中的login方法 --&gt; &lt;prop key="/register.php"&gt;register&lt;/prop&gt; &lt;!-- 对用控制器中的register方法 --&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 引用上方id名为springMethodNameResolver的解析器 --&gt;&lt;bean id="userController" class="com.fan.controllers.UserController"&gt; &lt;property name="methodNameResolver" ref="springMethodNameResolver"/&gt;&lt;/bean&gt; 3、发送请求登陆 成功跳转至message.jsp页面 http://localhost:81/login.php?username=ronaldo&amp;password=123 注册 成功跳转至login.jsp页面 http://localhost:81/register.php?username=ronaldo&amp;password=123&amp;repassword=123 二、Spring Interceptor拦截器Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter）,它主要用于拦截用户请求并作相应的处理。1、案例：只在8:00~18:00开放登陆2、编写拦截器如【LoginTimeInterceptor】12345678910111213141516171819202122232425262728293031323334public class LoginTimeInterceptor extends HandlerInterceptorAdapter &#123; private int startTime; private int endTime; public void setStartTime(int startTime) &#123; this.startTime = startTime; &#125; public void setEndTime(int endTime) &#123; this.endTime = endTime; &#125; //在控制器执行前调用 public Boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("&lt;======执行preHandle方法======&gt;"); Calendar cal = Calendar.getInstance(); int hour = cal.get(Calendar.HOUR_OF_DAY); //获取当前时间对应的小时数 if (hour &lt;= startTime &amp;&amp; hour &lt; endTime) &#123; return true; &#125; else &#123; request.setAttribute("msg","非登陆时段"); request.getRequestDispatcher("login.jsp").forward(request,response); return false; &#125; &#125; //在后端控制器执行后调用 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("&lt;======执行postHandle方法======&gt;"); super.postHandle(request, response, handler, modelAndView); &#125; //该方法在整个请求后执行完成后调用 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("&lt;======执行afterCompletion方法======&gt;"); super.afterCompletion(request, response, handler, ex); &#125;&#125; 可实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义 可实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义 3、编写SpringMvc配置文件如【 SpringMvc-core.xml 】12345678910111213141516171819&lt;bean id="simpleUrlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping" &gt; &lt;!-- 引用拦截器 --&gt; &lt;property name="interceptors"&gt; &lt;list&gt; &lt;ref bean="workTimeInterceptor"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/login.php"&gt;loginController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="loginController" class="com.fan.controllers.LoginController"/&gt;&lt;!-- 注入时间段 --&gt;&lt;bean id="workTimeInterceptor" class="com.fan.interceptors.LoginTimeInterceptor"&gt; &lt;property name="startTime" value="8"/&gt; &lt;property name="endTime" value="20"/&gt;&lt;/bean&gt; 4、登陆 如果当前系统时间为10:01:30，在该时段登陆能正常会自动跳转至消息页 如果当前时间为21:07:30，在该时段登陆会禁止登陆]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc 入门篇]]></title>
    <url>%2Fposts%2F6399%2F</url>
    <content type="text"><![CDATA[一、Hellow World1、所用版本为 spring-framework-4.3.9.RELEASE-dist2、编写web.xml配置文件12345678910111213141516171819&lt;!-- 配置SpringMvc核心Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 设置springmvc配置文件位置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:configs/SpringMvc-core.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 设置该启动器开启的顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 拦截以php结尾的请求 --&gt; &lt;url-pattern&gt;*.php&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; DispatcherServlet就是一个Servlet ，也是对请求进行转发的核心Servlet 上文表明所有以.php结尾的请求首先被DispatcherServlet处理，然后再把请求分发给对应的Controller load-on-startup标签标记容器是否在web应用程序启动的时候加载这个servlet 如果该元素的值为负数或者没有设置，该容器会当servlet被请求后再加载 它的值必须是一个整数，表示servlet被加载的先后顺序，值越小，servlet的优先级越高 2、编写xxxController12345678public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; String u = request.getParameter("userName"); //获取url的参数值 ModelAndView mav = new ModelAndView("message.jsp"); //默认跳转方式为转发;如需重定向需要加上redirect:关键字 mav.addObject("message",u + " say hello SpringMVC !!!"); //设置值 return mav; //返回ModelAndView对象 &#125;&#125; 必须实现Controller接口 通过ModelAndView实例化后的方法去设置数据与跳转的视图名 ModelAndView(“xxx.jsp”)相当于完成了servlet中的request.getRequestDispatcher(“xxx.jsp”) mav.addObject(“message”,”xxx”)相当于完成了servlet中的request.setAttribute() 3、编写SpringMvc配置文件如【 SpringMvc-core.xml 】123456789&lt;!-- 映射处理器simpleUrlHandlerMapping --&gt;&lt;bean id="simpleUrlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/hello.php"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="helloController" class="com.fan.controllers.HelloController"/&gt; 【&lt;bean id=”simpleUrlHandlerMapping”&gt;】是配置一个映射处理器 prop标签是把名称为/hello.php的请求交给名为helloController的bean处理 【&lt;bean id=”helloController” class=”com.fan.controllers.HelloController”&gt;】绑定对应的控制器 4、发送/hello.php的请求 二、初识视图解析器在SpringMvc-core.xml配置文件加上其配置即可 JSP解析器 123456&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/view/"/&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;property name="order" value="0"/&gt; &lt;property name="contentType" value="text/html;charset=UTF-8"/&gt;&lt;/bean&gt; HTML解析器 123456&lt;bean id="htmlviewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/view/"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;property name="order" value="0"/&gt; &lt;property name="contentType" value="text/html;charset=UTF-8"/&gt;&lt;/bean&gt; 设置后，我们控制器中的转跳地址就可以得到简化 ModelAndView mav = new ModelAndView(“message.jsp”); ==&gt; ModelAndView mav = new ModelAndView(“message”); 三、乱码处理在web.xml配置文件加上乱码过滤器即可123456789101112131415161718&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc 简述]]></title>
    <url>%2Fposts%2F5896%2F</url>
    <content type="text"><![CDATA[Spring MVC框架是一个MVC框架，通过实现Model-View-Controller模式来很好地将数据、业务与展示进行分离，Spring MVC和Struts2非常类似。Spring MVC的设计是围绕DispatcherServlet展开的，DispatcherServlet负责将请求派发到特定的handler。 一、了解SpringMvc Spring MVC 是一个模型 - 视图 - 控制器（MVC）的Web框架建立在中央前端控制器servlet（DispatcherServlet），它负责发送每个请求到合适的处理程序，使用视图来最终返回响应结果的概念。 Spring MVC 是 Spring 产品组合的一部分，它享有Spring IoC容器紧密结合Spring松耦合等特点，因此它有Spring的所有优点。 二、与Struts2细节对比 框架机制 Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC采用Servlet（DispatcherServlet）实现 Filter在容器启动后即初始化,服务停止以后销毁,晚于Servlet调用。Servlet在调用时初始化,先于Filter调用,服务停止后销毁 性能方面 SpringMVC开发效率和性能高于Struts2。因为SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入 拦截机制 Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式 设计思想 Struts2更加符合OOP的编程思想， SpringMVC只在servlet上扩展 三、与Struts2总体对比 Struts2 Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype然后通过setter，getter把request数据注入到属性 Struts2中，一个Action对应一个request、response，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的 Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了 SpringMVC SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法基本上是独立的，独享request、response数据 每个方法同时又可与一个url对应，参数的传递是直接注入到方法中的，是方法所独有的，处理结果通过ModeMap返回给框架 在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，因为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改 四、SpringMVC核心流程图及解析 DispatcherServlet(前端控制器) 应用了“ Front Controller”模式 – 是所有 Spring MVC 请求的中枢 继承了HttpServlet，是一个Servlet，由WebApplicationContext 加载 如果不作其它配置，会加载默认组件 HandlerMapping(映射处理器) 将web请求映射到正确的处理器（handler）上 , 通常是一个 Controller 不需用自定义处理器映射–已经内置了很多处理器映射策略 在处理器映射中通过配置拦截器（包括处理器执行前、执行后、或者执行前后运行拦截器）将使其功能更强大 Controller (后端控制器) 负责处理请求 内部参数继承 HttpServlethandleRequest(HttpServletRequest, HttpServletResponse) 返回一个 ModelAndView对象 所有实现都是线程安全的 基本不用自己实现接口 – 已经提供了很多实用的实现类 ModelAndView 对象 封装了用来渲染页面的 model和view Model 用 java.util.Map实现的 添加对象，可以不需用名字 addObject(String, Object) – 用显式名字添加 addObject(Object) – 用默认名添加 (惯例优先) View 用 String 或 View 对象表示 类似 Struts的 Action Interceptors(拦截器) 在请求前后添加其它功能 包括拦截器方法 – preHandle and postHandle 包括回调方法 – afterCompletetion 可以通过 HandlerMapping 和一系列Controller关联上 ViewResolver(视图解析器) 从一个逻辑视图名映射到一个视图对象 View(视图) InternalResourceView (JSP) JstlView (JSP + JSTL) VelocityView (Velocity) FreeMarkerView (FreeMarker) TilesView (Tiles) TilesJstlView (Tiles + JSTL) 原文地址作者：易白教程 / 水草滩 / 冯如链接：https://www.yiibai.com/spring_mvc/https://blog.csdn.net/jishuizhipan/article/details/79385190https://www.cnblogs.com/fengru/p/5730174.html来源：易白教程 / CSDN / 博客园]]></content>
      <tags>
        <tag>转载</tag>
        <tag>后端</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 基于注解开发]]></title>
    <url>%2Fposts%2F52271%2F</url>
    <content type="text"><![CDATA[一、Mybatis基于注解开发MyBatis3.0+ 提供了全面的基于注解开发，使用注解可以简化XML配置，但是注解方式并不是XML配置文件的替代者，因为有许多的操作注解并没有普及，而且注解是快速开发，不利于我们之后的维护和扩展。 二、Mybatis常用注解表注解目标对应的XML标签@CacheNamespace类&lt;cache&gt;@CacheNamespaceRef类&lt;cacheRef&gt;@Results方法&lt;resultMap&gt;@Result方法&lt;result&gt;&lt;id&gt;@One方法&lt;association&gt;@Many&nbsp;&nbsp;方法&lt;collection&gt;@Insert@Update@Delete方法&lt;insert&gt;&lt;update&gt;&lt;delete&gt;@InsertProvider@UpdateProvider@DeleteProvider@SelectProvider方法&lt;insert&gt;&lt;update&gt;&lt;delete&gt;&lt;select&gt;允许创建动态SQL@Param&nbsp;参数N/A@Options&nbsp;方法映射语句的属性@select方法&lt;select&gt; 三、基本SQL实例如下： 新增 123@Insert("INSERT INTO student(stuName,gender,age,address,deptIdd) VALUES(#&#123;stuName&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;address&#125;,#&#123;deptIdd&#125;)")@Options(useGeneratedKeys = true, keyColumn = "stuId")int saveOne(StudentEntity student); 删除 12@Delete("DELETE FROM student WHERE stuId = #&#123;stuId&#125;")int deleteOne(Integer id); 修改 123@Update("UPDATE student SET stuName = #&#123;stuName&#125;,gender = #&#123;sex&#125; WHERE stuId = #&#123;stuId&#125;")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;) //配置与列名不一致的属性即可int modifyOne(StudentEntity student); 查询 1234@Select("SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;) //配置与列名不一致的属性即可@Options(useCache = true,flushCache = false,timeout = 6000)List&lt;HashMap&gt; queryMany(); 四、动态SQL动态SQL的话我们需要创建，一个能帮我们动态返回的SQL语句类，然后Dao层接口通过反射调用其方法。实例如下： 新增 123@SelectProvider(type = TrendSQLProvider.class,method = "trendSaveOne")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;)Integer trendSaveOne(StudentEntity student); 删除 12@DeleteProvider(type = TrendSQLProvider.class,method = "trendDeleteOne")Integer trendDeleteOne(Integer id); 修改 123@UpdateProvider(type = TrendSQLProvider.class,method = "trendModifyOne")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;)Integer trendModifyOne(StudentEntity student); 查询 123@SelectProvider(type = TrendSQLProvider.class,method = "trendQueryStuList")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;)List&lt;StudentEntity&gt; trendQueryStuList(Map&lt;String, Object&gt; param); 上面四条curd执行语句都用到的type和method，分别代表着指定一个类和这个类中指定的方法 TrendSQLProvider类如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 生成动态SQL的工具类public class TrendSQLProvider &#123; /*新增*/ public String trendSaveOne(StudentEntity student) &#123; return new SQL() &#123; &#123; INSERT_INTO("student"); if (student.getStuId() != null) &#123; VALUES("stuId", "#&#123;stuId&#125;"); &#125; if (student.getStuName() != null) &#123; VALUES("stuName", "#&#123;stuName&#125;"); &#125; if (student.getSex() != null) &#123; VALUES("gender", "#&#123;sex&#125;"); &#125; if (student.getAge() != null) &#123; VALUES("age", "#&#123;age&#125;"); &#125; if (student.getAddress() != null) &#123; VALUES("address", "#&#123;address&#125;"); &#125; if (student.getDeptIdd() != null) &#123; VALUES("deptIdd", "#&#123;deptIdd&#125;"); &#125; &#125; &#125;.toString(); &#125; /*删除*/ public String trendDeleteOne(Integer id) &#123; return new SQL() &#123; &#123; DELETE_FROM("student"); if (id != null) &#123; WHERE("stuId = #&#123;id&#125;"); &#125; &#125; &#125;.toString(); &#125; /*修改*/ public String trendModifyOne(StudentEntity student) &#123; return new SQL() &#123; &#123; UPDATE("student"); if (student.getStuName() != null) &#123; SET("stuName = #&#123;stuName&#125;"); &#125; if (student.getSex() != null) &#123; SET("gender = #&#123;sex&#125;"); &#125; WHERE("stuId = #&#123;stuId&#125;"); &#125; &#125;.toString(); &#125; /*查询*/ public String trendQueryStuList(Map&lt;String, Object&gt; param) &#123; return new SQL() &#123; &#123; SELECT("*"); FROM("student"); if (param.get("stuName") != null) &#123; WHERE("stuName like concat('%',#&#123;stuName&#125;,'%')"); &#125; if (param.get("age") != null) &#123; WHERE("age &gt;= #&#123;minAge&#125;"); &#125; &#125; &#125;.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 缓存机制]]></title>
    <url>%2Fposts%2F52270%2F</url>
    <content type="text"><![CDATA[一、Mybatis缓存机制 mybatis提供了强大的缓存机制减轻数据库压力，提高数据库性能 mybatis的缓存分为：一级缓存、二级缓存 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的 如果SqlSession执行了DML操作（insert、update、delete），并提交事务了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的数据永远和数据库中一致，避免出现脏读取 二、一级缓存 MyBatis的一级缓存默认开启的 第一次执行查询完毕后，会将查到的数据写入SqlSession内的HashMap中缓存起来 第二次如果执行相同的查询，会直接到从缓存中返回数据，从而提高了效率 实例，执行两次相同的查询 123456789public static void main(String[] args) &#123; SqlSession session= MybatisUtil.getSession(); StudentEntity stu0 = session.selectOne("StuMapper.queryOne", 100); System.out.println(stu0.getStuName() + "--" + stu0.getGender()); MybatisUtil.colseSession(); //执行第二次相同查询时，先关闭Session SqlSession session= MybatisUtil.getSession(); //然后再次开启 StudentEntity stu1 = session.selectOne("StuMapper.queryOne", 100); System.out.println(stu1.getStuName() + "--" + stu1.getGender());&#125; 执行的结果，我们可以从中看出两次查询，系统默认只执行了一次SQL查询 三、二级缓存 MyBatis的二级缓存不是默认开启的 二级缓存是mapper级别的缓存，也就是同一个namespace的xxxMapper.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域 实例 在Mybatis核心配置文件【 mybatis-core.xml 】中开启缓存 123&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 在须要开启二级缓存的【 xxxMapper.xml 】中配置缓存 1&lt;cache eviction="LRU" flushInterval="60000" size="2048" readOnly="true"/&gt; 这里配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的 参数详情表 选项 默认值 eviction 可用资源的回收策略，主要包含如下几种: LRU：较少使用的、移除最长时间不被使用的对象FIFO：(先进先出)：按对象进入缓存的顺序将其移除SOFT(软引用)：移除基于垃圾回收器状态和软引用规则的对象WEAK(弱引用)：积极地移除基于垃圾收集器状态和弱引用规则的对象 flushInterval 刷新间隔，可以被设置为任意的正整数，它们代表一个合理的毫秒形式的时间段。默认情况下不设置，即没有刷新间隔，缓存仅在调用语句时刷新 size 引用数目，可以被设置为任意正整数，要牢记缓存的对象数目和运行环境的可用内存资源数目默认值为1024 readOnly 只读属性可以被设置为true或false只读的缓存设置会给所有调用者返回缓存对象的相同实例因此这些对象不能被修改。此处提供了很重要的性能优势可读写的缓存会返回缓存对象的拷贝（通过序列化这样较为缓慢，但比较安全，因此默认为false 执行结果如下]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 关联映射]]></title>
    <url>%2Fposts%2F27661%2F</url>
    <content type="text"><![CDATA[一、Mybatis关联映射在实际的项目开发中，我们不可能只对单表进行操作。从而有了一对一、一对多、多对一的多表关联，以下采用学生表(Student)和系表(Department)进行操作。 二、多对一 如学生表(Student)对应系表(Department)构成多对一关系 学生实体 12345678public class StudentEntity implements Serializable &#123; private Integer stuId; private String stuName; private String sex; //此字段与数据库列名不一致 /* 多对一关联系表的属性 */ private DepartmentEntity dept; 省略get、set方法...&#125; DepartmentMapper.xml 系映射文件 123&lt;resultMap id="deptMap" type="DepartmentEntity" autoMapping="true"&gt; &lt;id property="deptId" column="deptId"/&gt;&lt;/resultMap&gt; StudentMapper.xml 学生映射文件 12345&lt;resultMap id="stuJoinDept" type="StudentEntity" autoMapping="true"&gt; &lt;id property="stuId" column="stuId"/&gt; &lt;result property="sex" column="gender"/&gt; &lt;!-- 因为属性名和列名不同所以要单独做映射 --&gt; &lt;association property="dept" javaType="DepartmentEntity" resultMap="com.fan.dao.IDepartmentDao.deptMap"/&gt;&lt;/resultMap&gt; PS 如果映射文件使用了autoMapping=”true”时，表示自动映射列名和属性名相同的属性，不相同的就要单独做映射 ID列是必须带有的 association标签是多对一的关键字，property属性填写当前实体关联的实体，javaType属性填写当前关联实体的类型，resultMap属性填写关联实体resultMap的ID SQL配置123&lt;select id="queryStuOne" parameterType="int" resultMap="stuJoinDept"&gt; SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId where s.stuId = #&#123;stuId&#125;&lt;/select&gt; 三、一对多 如系表(Department)对应学生表(Student)构成一对多关系 系实体 1234567public class DepartmentEntity implements Serializable &#123; private Integer deptId; private String departName; /* 一对多关联学生表的属性 */ private List&lt;StudentEntity&gt; stuList = new ArrayList&lt;&gt;(); 省略get、set方法...&#125; StudentMapper.xml 系映射文件 1234&lt;resultMap id="stuMap" type="StudentEntity" autoMapping="true"&gt; &lt;id property="stuId" column="stuId"/&gt; &lt;result property="sex" column="gender"/&gt; &lt;!-- 因为属性名和列名不同所以要单独做映射 --&gt;&lt;/resultMap&gt; DepartmentMapper.xml 系映射文件 1234&lt;resultMap id="deptJoinStu" type="DepartmentEntity" autoMapping="true"&gt; &lt;id property="deptId" column="deptId"/&gt; &lt;collection property="stuList" javaType="arrayList" ofType="StudentEntity" resultMap="com.fan.dao.IStudentDao.stuMap"/&gt;&lt;/resultMap&gt; PS collection 标签是一对多的关键字，property属性填写当前实体关联的实体，javaType属性填写当前关联实体的类型，resultMap属性填写关联实体resultMap的ID SQL配置123&lt;select id="queryDeptToStuList" resultMap="deptJoinStu"&gt; SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId&lt;/select&gt; 四、利用HashMap的“万能关联”由于Mybatis的关联是很灵活的，不管几对几，我们都可以不用任何关联配置。 Dao层接口 123public interface IStudentDao &#123; List&lt;HashMap&gt; queryStuListByMap(); //查询全部学的详情&#125; List集合中的类型必须是HashMap SQL配置 123&lt;select id="queryStuListByMap" parameterType="map" resultType="map"&gt; SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId&lt;/select&gt; 返回值的类型必须是HashMap 调用 12345678public static void main(String[] args) &#123; SqlSession session = MybatisUtil.getSession(); IStudentDao studentDao = session.getMapper(IStudentDao.class); List&lt;HashMap&gt; list = studentDao.queryStuListByMap(); for (HashMap stu : list) &#123; System.out.println(stu.get("stuName") + "--" + stu.get("gender") + "--" + stu.get("departName")); &#125;&#125; 通过获取HashMap中的Key得到Value]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用宝塔面板上传Java Web项目]]></title>
    <url>%2Fposts%2F4240%2F</url>
    <content type="text"><![CDATA[一、安装宝塔Linux面板 6.7 系统要求 支持 CentOS、Ubuntu、Debian、Fedora、Deepin系统 确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL 内存要求最低512MB 使用SSH连接工具连接到您的 Linux 服务器后，执行如下Centos安装指令1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 二、环境安装 进入你的宝塔服务器控制面板 安装 Tomcat [ 默认安装好tomcat时给你自带JDK，例如 tomcat7对应JDK1.7 tomcat8对应JDK1.8… ] MySQL [ 推荐安装Mysql5.5 or 5.7 ] Nginx [ 推荐安装Nginx 1.14.1 ] 其他根据需求而定 三、部署项目未完待续]]></content>
      <tags>
        <tag>原创</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 面向接口编程]]></title>
    <url>%2Fposts%2F27225%2F</url>
    <content type="text"><![CDATA[一、Mybatis面向接口编程Mybatis面向接口编程是mybatis的独有的特性。对比之前的Hiberbate我们通常是定义好一个Dao层接口，然后在定义一个DaoImpl的实现进行编程，这样定义结构清晰，方便维护和扩展。如果用mybatis处理Dao层的话，就可以直接省略实现类，直接在mapper.xml配置文件中编写，这样就可以通过接口访问映射文件。 二、代码实例 Dao层接口 1234public interface IBillDao &#123; /*根据名称模糊查询所有的订单*/ List&lt;BillEntity&gt; queryBillByName(String productName);&#125; Mapper.xml映射文件 12345&lt;mapper namespace="com.fan.dao.IBillDao"&gt; &lt;select id="queryBillByName" parameterType="String" resultType="BillEntity"&gt; SELECT * FROM smbms_bill WHERE productName LIKE concat('%',#&#123;productName&#125;,'%') &lt;/select&gt;&lt;/mapper&gt; Main方法调用 12345678public static void main(String[] args) &#123; SqlSession session = MybatisUtil.getSession(); IBillDao billDao = session.getMapper(IBillDao.class); List&lt;BillEntity&gt; list = billDao.queryBillByName("饮料"); for (BillEntity bill : list) &#123; System.out.println(bill.getBillCode() + "--" + bill.getProductName()); &#125;&#125; PS Mapper.xml映射文件中namespace必须是 ‘包名.接口名’，如com.fan.dao.IBillDao Mapper.xml映射文件中Id必须与 接口的方法名一致 调用时通过session.getMapper(接口.class)，获得接口实例]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 动态SQL]]></title>
    <url>%2Fposts%2F64677%2F</url>
    <content type="text"><![CDATA[一、Mybatis动态SQL本篇所讲的使用mybatis动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。 二、基本标签 If标签 123456789&lt;select id="queryByCondition" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student WHERE 1 = 1 &lt;if test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/if&gt; &lt;if test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/if&gt;&lt;/select&gt; parameterType类型我们用到了一个自定义参数的实体类，当然可以使用map集合替代 如果studentName和minAge全部满足条件 1SELECT * FROM student WHERE 1 = 1 AND studentName like ? AND minAge= ? 如果全不满足条件 1SELECT * FROM student WHERE 1 = 1 Where标签 + If标签 1234567891011&lt;select id="queryByWhere" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student &lt;where&gt; &lt;if test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/if&gt; &lt;if test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where元素的作用是在写入where元素的地方输出一个where MyBatis会智能处理输出条件，如果所有条件都不满足，那么MyBatis会查出所有的记录 如果输出后是以and开头的，MyBatis会把第一个and忽略 因此不用写1=1这样的条件 Set标签 + Where标签 123456789101112&lt;update id="modifyOne" parameterType="StudentEntity"&gt; UPDATE student &lt;set&gt; &lt;if test="stuName != null"&gt; stuName = #&#123;stuName&#125;, &lt;/if&gt; &lt;if test="gender != null"&gt; gender = #&#123;gender&#125;, &lt;/if&gt; &lt;/set&gt; WHERE stuId = #&#123;stuId&#125;&lt;/update&gt; 注意的是，if语句里面的需要以 ‘,’ 逗号结尾，如果只有一条语句合适的话，mybatis会自动处理最后的逗号 如果studentName和minAge全部满足条件 1UPDATE student SET stuName = ? AND gender = ? WHERE stuId = ? 如果全不满足条件，就不会做出任何修改 Choose(when,Otherwise)标签 1234567891011121314&lt;select id="queryByCondition" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student WHERE 1 = 1 &lt;choose&gt; &lt;when test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/when&gt; &lt;when test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/when&gt; &lt;otherwise&gt; and state = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 不论在什么情况下都会执行otherwise标签，例如1SELECT * FROM student WHERE 1 = 1 and state = 1 Trim标签 trim标记是一个格式化的标记，可以完成Set或者是Where标记的功能 例如分别修改查询和更新语句 1234567891011&lt;select id="queryByTrim" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student &lt;trim prefix="WHERE" prefixOverrides="and|or"&gt; &lt;if test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/if&gt; &lt;if test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; prefix代表前缀 prefixoverride代表去掉第一个and或者是or 1234567891011&lt;update id="modifyOneByTrim" parameterType="StudentEntity"&gt; UPDATE student &lt;trim prefix="SET" suffix="WHERE stuId = #&#123;stuId&#125;" suffixOverrides=","&gt; &lt;if test="stuName != null"&gt; stuName = #&#123;stuName&#125;, &lt;/if&gt; &lt;if test="gender != null"&gt; gender = #&#123;gender&#125;, &lt;/if&gt; &lt;/trim&gt;&lt;/update&gt; suffix代表前缀，一般把最后的条件语句写在里面 suffixOverrides代表去掉最后一个 ‘,’ 逗号 三、Foreach标签 foreach标签操作需求是对一个集合进行遍历，通常是在构建IN条件语句的时候，我们通常用作批量删除、添加、和in查询字句 实例 123456&lt;delete id="delBatch"&gt; DELETE from student WHERE stuId in &lt;foreach collection="array" item="id" open="(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/delete&gt; 调用 先定义一个int类型的数组，然后作为参数后传入 1234567static void delBatch(SqlSession session) &#123; int[] theArr = new int[]&#123;123, 124, 125&#125;; int res = session.delete("StuMapper.delBatch", theArr); if (res &gt; 0) &#123; System.out.println("删除成功：" + res); &#125;&#125; 释意 collection代表传入的参数类型，常用的有array、list、map三种，分别对应的参数类型为数组、List、Map集合 item代表迭代过程中的每一个元素的别名 index代表每次迭代的下标 open代表前缀 cloase代表后缀 separator分隔符，表示迭代时每个元素之间以什么分隔]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo-Github域名绑定(阿里云)]]></title>
    <url>%2Fposts%2F56994%2F</url>
    <content type="text"><![CDATA[一、起步 Node.js Git Hexo GitHub环境已搭建 域名已经实名认证 二、开始 得到GitHub仓库名[ 如crbug.github.io ]的IP值我的是 185.199.111.153 域名解析 打开阿里云域名控制台点击解析后点击新手引导，填入我们之前CMD命令ping好的值–&gt;如185.199.111.153会给我们生成两条A记录值修改第一条A值为CNAME值(CNAME记录的记录值为域名形式（如abc.example.com）)，其值填写自己GitHub仓库名即可 三、修改GitHub仓库 进入自己Hexo的仓库，点击设置 往下滑找到当前页面GitHub Pages项中的Custom domain，修改值为自己的域名 四、修改本地Hexo 进入Hexo项目下的source文件夹，创建一个文件命名为CNAME，里面填写自己需要绑定的阿里云域名，等待10分钟左右即可]]></content>
      <tags>
        <tag>原创</tag>
        <tag>Hexo指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上帝偏爱奔跑者]]></title>
    <url>%2Fposts%2F43820%2F</url>
    <content type="text"><![CDATA[&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;2013年，英超豪门阿森纳足球俱乐部的官方网站发布了一部短片，纪念一位越南的“Running Man”（奔跑者）。片头是：每一个故事里都有一个英雄，在这一次的旅途中，英雄出现了——The Running Man。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;短片一经发布，这位越南球迷即刻风靡全球。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;发布前一天，阿森纳队刚刚抵达越南。作为一支英超球队，此番访问越南尚属首次。因此，他们一到，立即引起了轰动。一群狂热的球迷一路奔跑，追赶着偶像乘坐的大巴车。可是，路途很长，车速也不慢。许多人在追赶一段后便放弃了。可是，有一个小伙子却一直坚持着。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;小伙子20岁上下，肤色黝黑，笑容爽朗。尽管大巴车一直以较快的速度前行，可是，他奔跑的速度也不慢，总能适时跟上。小伙子不断地朝车内的群星微笑，向他们挥手，向他们竖起大拇指。车内，球星们也不断回应，露出善意的笑容。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;大步奔跑，不断挥手示意，始终不渝地微笑着。这样的奔跑画面感染了每一位阿森纳球员。他们不断地朝他挥手、微笑、呐喊。车有多快，奔跑便有多快。那是一条长长的道路，途经闹市、街道、人群……一边望向车内，一边急速奔跑，他免不了摔跤。是的，他因一根灯柱而摔倒过，他因一棵大树而撞着了头……每一次，当他摔倒的时候，球星们便发出遗憾之叹。可是随即，他们又欢呼起来：这位了不起的小伙子迅速从地上爬起，仍然保持着那爽朗的笑容，向他们挥手，跟着他们继续前行。他不曾停歇。他只知道，他要一直追赶他们。就如夸父一样，这是一个奔向太阳的史诗般的“英雄”。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;目睹这位充满激情的小伙子奔跑、跌倒、爬起、微笑、再奔跑的过程，球星们对他肃然起敬。所有的球员都跑向车厢那一侧，对他唱了起来：“Sign him up（签下他）！Sign him up……”当然，这是玩笑话，但是，这位球迷身上的热情与激情深深打动了他们。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;他跑了足足5公里。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;他终于乏了。不过，他没有停下，而是换乘一辆摩托车，继续他的“追梦”之路。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;看着他如此不懈地追逐，带队教练终于发话，停下车，为他开启了一扇通向梦想的大门——他有了与阿森纳球员零距离接触的机会。见自己的奔跑没有白费，他振臂欢呼。与他一齐欢呼的，还有车上所有的队员和教练。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;车内，所有的球星一一起立，迎接这位他们刚刚“签下”的新成员。小伙子与他们握手、拥抱、合影，求取签名。他与阿尔特塔并肩而坐，一只手友好地搭在这位著名球星的肩上，另一只手则振臂高呼。这样的一张照片成了阿森纳与球迷合影的经典之照。前锋吉鲁把这一过程完整地拍了下来。当他把视频放上Facebook时，全世界的人都惊叹了。有网友评论：“惊人的耐力、体力和忠诚度！难道他就是温格传说中的7000万引援？签了他！”&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;这是幽默而善意的评论，还有很多人为他喝彩。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;可是，更令人意外的是，2013年7月17日，当阿森纳队与越南队一同出现在绿茵球场时，这位“奔跑者”居然获得了与阿森纳球星一同出场的机会，成为阿森纳“名副其实”的“首发”球员。站在球场上，他与波多尔斯基谈笑风生。他参加双方球员例行的握手仪式。赛后，他还获得了温格赠送的机票、球票和酒店住宿待遇。于是，在将来的某一天，这位幸运的“奔跑者”将前往伦敦，去观看足球比赛。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;对于一位追梦的人来说，这也是他获得的最高礼遇。这位红透全世界的越南小伙子，在忘我的奔跑中追寻到了他的梦想。这不仅仅是一个球迷对于球星的向往和追求，更是关于青春、关于“梦”的追求。就在那样疯狂的奔跑中，他实现了原本遥不可及的梦想。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;所有的球迷在为他高兴的同时，也在艳羡他的境遇。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;然而，并不是所有人都那么“幸运”。因为，世界上分为两种人：一种是奔跑者，一种是观望者。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;而上帝，往往偏爱那些拼尽全力的疯狂的奔跑者。 文章来源链接：http://www.ledu365.com/a/lizhi/49888.html来源：乐读网]]></content>
      <tags>
        <tag>转载</tag>
        <tag>文章推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis CURD操作]]></title>
    <url>%2Fposts%2F27655%2F</url>
    <content type="text"><![CDATA[一、MybatisUtil工具类MybatisUtil工具类主要是为了简化开发、提升开发速率。在没整合Spring之前方便统一管理Session等好处。以下两个版本的代码所执行的结果一致，完整版考虑的周到代码健壮性更好，两版本没本质区别！ 完整版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MybatisUtil &#123; private static final String CONFIGFILE = "mybatis-core.xml"; //当前线程存在session中 private static final ThreadLocal&lt;SqlSession&gt; THREAD_LOCAL = new InheritableThreadLocal&lt;&gt;(); private static Reader reader = null; private static SqlSessionFactoryBuilder builder = null; private static SqlSessionFactory factory = null; //用静态代码块进行初始化 static &#123; try &#123; //加载配置文件 reader = Resources.getResourceAsReader(CONFIGFILE); //得到工厂创建对象 builder = new SqlSessionFactoryBuilder(); //得到工厂对象 factory = builder.build(reader); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获得工厂对象 public static SqlSessionFactory getFactory() &#123; if (factory == null) &#123; factory = builder.build(reader); &#125; return factory; &#125; //得到session public static SqlSession getSession() &#123; SqlSession session = THREAD_LOCAL.get(); if (session == null) &#123; SqlSessionFactory factory = getFactory(); session = factory.openSession(); THREAD_LOCAL.set(session); &#125; return session; &#125; //关闭session public static void colseSession() &#123; SqlSession session = THREAD_LOCAL.get(); if (session != null) &#123; session.close(); &#125; THREAD_LOCAL.set(null); &#125;&#125; 简化版 1234567891011121314151617181920public class MybatisUtil &#123; private static SqlSessionFactory factory; static &#123; try &#123; factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-core.xml")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSession() &#123; return factory.openSession(false); //true 为自动提交事务 &#125; public static void closeSession(SqlSession sqlSession) &#123; if (null != sqlSession) &#123; sqlSession.close(); &#125; &#125;&#125; 二、自增、模糊查询、分页查询及Map传参 设置主键自动增长 123&lt;insert id="saveOne" parameterType="StudentEntity" useGeneratedKeys="true" keyProperty="stuId"&gt; INSERT INTO student VALUES(NULL,#&#123;stuName&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;address&#125;,NULL)&lt;/insert&gt; 释意: useGeneratedKeys表示是否使用JDBC的getGenereatedKeys方法获取主键，并赋值到keyProperty设置的属性中 keyProperty需要自动增长的主键名称 模糊查询 123&lt;select id="queryByVague" parameterType="String" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.stuName like concat('%',#&#123;stuName&#125;,'%')&lt;/select&gt; 释意: MySQL中concat函数，返回结果为拼接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL 使用Map集合传参 123&lt;select id="queryByFactor" parameterType="map" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.gender = #&#123;gender&#125; AND student.age &gt; #&#123;minAge&#125;&lt;/select&gt; 释意: 调用时注意map集合里面的键一定要与传参命名一致 1234Map parame = new HashMap();parame.put("gender", "男");parame.put("minAge", 30);List&lt;StudentEntity&gt; list = session.selectList("StuMapper.selMap", parame); 别名与Java类型映射表(常用类型) 别名 映射的类型 boolean Boolean string String double Double int Intrger intrger Intrger list List arraylist ArrayList map Map hashMap HashMap 分页查询 123&lt;select id="queryByPage" parameterType="map" resultType="StudentEntity"&gt; SELECT * FROM student WHERE gender = #&#123;gender&#125; ORDER BY stuId DESC LIMIT #&#123;start&#125;,#&#123;end&#125;&lt;/select&gt; 释意: 调用时仍然采用map集合传参，注意下分页的页码12345Map parame = new HashMap&lt;&gt;();parame.put("gender", "男");parame.put("start", (pageNo - 1) * pageSize);parame.put("end", pageSize);List&lt;StudentEntity&gt; list = session.selectList("StuMapper.queryByPage", parame); 三、当实体类的属性和数据库中表的列名不一致 需要在映射文件中重新绑定属性与列名 123&lt;resultMap id="diyMapping" type="StudentEntity" autoMapping="true"&gt; &lt;result property="sex" column="gender"/&gt;&lt;/resultMap&gt; 释意: id代表这个resultMap的唯一标识 type代表需要重新映射的实体类也可以是之前设置的别名 autoMapping=”true”表示自动映射列名和属性名相同的属性，不相同的就要单独做映射 下面语句中的resultMap填写上面的ID即可123&lt;select id="queryCount" resultMap="diyMapping"&gt; select count(*) from student&lt;/select&gt;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pjax]]></title>
    <url>%2Fposts%2F44568%2F</url>
    <content type="text"><![CDATA[Pjax是一个jQuery插件，它通过ajax和pushState技术提供了极速的（无刷新ajax加载）浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。 一、我眼中的PjaxPjax === PushState(修改地址栏的Url) + Ajax(异步无刷新技术)。简单的来说pjax是这两个技术的结合，执行原理ajax负责去后端请求部分html片段或者json数据，通过渲染到指定的div容器中，再由pushstate刷新当前的url地址，但是并不会造成页面的闪动，因此提升用户网页浏览体验。 二、Pjax的工作原理pjax的工作原理是通过ajax从服务器端获取HTML，在页面中用获取到的HTML替换指定容器元素中的内容。然后使用pushState技术更新浏览器地址栏中的当前地址。 三、Pjax的优缺点 优点： 不存在页面资源（js/css）的重复加载和应用 如果服务器端配置了pjax，它可以只渲染页面局部内容，从而避免服务器渲染完整布局的额外开销 缺点 不支持一些低版本的浏览器(如IE系列)，因为pushState是html5中history的新特性，在某些旧版浏览器中可能不支持 使服务端处理变得复杂 pjax依赖于jQuery 1.8或者更高版本 四、Pjax起步 通过npm安装 or 通过js引入(首先得引入jqeury)12$ npm install jquery-pjaxhttps://raw.github.com/defunkt/jquery-pjax/master/jquery.pjax.js 五、Pjax方法 $.fn.pjax 概述 1$(document).pjax(selector, [container], options) 1.selector：string类型，用于click 事件委托的选择器 2.container：string类型，用于标识唯一pjax容器的选择器 3.options object类型，包含下列选项 选项 默认值 说明 timeout 650 ajax超时时间（毫秒），超时后强制刷新整个页面 push true 使用 pushState 在浏览器中添加历史记录 replace false 替换URL地址但不添加浏览器历史记录 type “GET” 请求类型 dataType “html” 服务器端返回的数据类型 type “GET” 请求类型 url link.href string或function，返回ajax请求响应的URL 全局使用$.pjax.defaults对象改变默认配置，如下 $.pjax.defaults.timeout = 1200 $.fn.pjax 用法 最简单常见的pjax使用方法如下： 1$(document).pjax('a', '#pjax-container') pjax()方法能若干个参数，上文涉及到的‘a’和’#pjax-container’。‘a’代表所有的a标签链接，而‘#pjax-container’代表需要替换内容的容器。通过这种方式可以让页面中所有的链接都实现pjax加载，并指定ID为pjax-container的作为容器元素。 如果我们想指定a标签作为pjax链接使用方法如下： 1$(document).pjax('[data-pjax] a, a[data-pjax]', '#pjax-container') 那么我们可以用data-pjax来注明这是一个pjax链接，然后使用a[data-pjax]来代替全局选择器a。 六、事件 $.pjax.click 点击事件 本示例使用当前的click上下文来设置一个祖先元素作为容器：1234567if ($.support.pjax) &#123; $(document).on('click', 'a[data-pjax]', function(event) &#123; var container = $(this).closest('[data-pjax-container]') var containerSelector = '#' + container.id $.pjax.click(event, &#123;container: containerSelector&#125;) &#125;)&#125; $.pjax.submit 表单提交事件 通过pjax提交表单123$(document).on('submit', 'form[data-pjax]', function(event) &#123; $.pjax.submit(event, '#pjax-container')&#125;) $.pjax.reload 重载事件 使用pjax机制发起一个当前URL的请求到服务器，并且通过响应的内容替换容器元素中的内容，同时不添加浏览器历史记录。1$.pjax.reload('#pjax-container', options) $.pjax 手动调用pjax事件 主要用于非click事件发起pjax请求的情况。如果可以获得click事件，请使用$.pjax.click(event)来代替。1234function applyFilters() &#123; var url = urlForFilters() $.pjax(&#123;url: url, container: '#pjax-container'&#125;)&#125; 七、文档链接：https://github.com/defunkt/jquery-pjax来源：github链接：http://bsify.admui.com/jquery-pjax/来源：bsify]]></content>
      <tags>
        <tag>转载</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活在你的时区]]></title>
    <url>%2Fposts%2F49663%2F</url>
    <content type="text"><![CDATA[纽约时间比加州时间早三个小时，New York is 3 hours ahead of California但加州时间并没有变慢。but it does not make California slow有人22岁就毕业了，Someone graduated at the age of 22但等了五年才找到好的工作！but waited 5 years before securing a good job有人25岁就当上CEO，却在50岁去世。Someone became a CEO at 25，and died at 50也有人迟到50岁才当上CEO，然后活到90岁。While another became a CEO at 50 and lived to 90 years.有人依然单身，同时也有人已婚。Someone is still single，while someone else got married.奥巴马55岁就退休，川普70岁才开始当总统。Obama retires at 55，but Trump starts at 70世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone身边有些人看似走在你前面，People around you might seem to go ahead of you也有人看似走在你后面。some might seem to be behind you但其实每个人在自己的时区都有自己的步伐。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours生命就是等待正确的行动时机。Life is about waiting for the right moment to act所以，放轻松、你没有落后、你没有领先。So, RELAX、You’re not LATE、You’re not EARLY在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 文章来源作者：HIGO链接：https://www.zhihu.com/question/38874036/answer/458029368来源：知乎]]></content>
      <tags>
        <tag>转载</tag>
        <tag>文章推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用指令]]></title>
    <url>%2Fposts%2F55256%2F</url>
    <content type="text"><![CDATA[一、Hexo安装及初始化123npm install hexo-cli -g #安装npm update hexo -g #升级hexo init #初始化 二、常用指令 新建草稿 1hexo new draft "文章名称" 新建文章 1hexo n "文章名称" === hexo new "文章名称" 发布文章 1hexo publish "文章名称" 启动服务 1hexo s === hexo server 部署至服务器 1hexo d === hexo deploy 清除缓存 1hexo clean 更改端口 1hexo server -p 端口号 自定义IP 1hexo s -i ip地址 生成静态页面至public目录 1hexo g === hexo generate Ps:可与hexo g 合并为 hexo d -g / hexo g -d 三、插件推荐 1 文章置顶12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 文章添加top值即可 2 文章封面1npm install --save hexo-less 一张图片外链和less标签即可,该封面图不会出现在正文效果图如下 四、报错异常 1 找不到git部署及解决方法12ERROR Deployer not found: gitnpm install hexo-deployer-git --save 2 部署类型设置git –&gt;打开你博客的根目录，找到 _config.yml配置文件123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:github用户名/github用户名.github.io branch: master 五、查看更多详情 Hexo官方文档 https://hexo.io/zh-cn/ 大佬们的教程 https://segmentfault.com/a/1190000002632530 https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.bilibili.com/video/av17653359]]></content>
      <tags>
        <tag>原创</tag>
        <tag>Hexo指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 入门篇]]></title>
    <url>%2Fposts%2F44195%2F</url>
    <content type="text"><![CDATA[MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。是一个基于Java的持久层框架。 一、了解Mybatis MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集 MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录 二、与Hibernate对比 MyBatis与Hibernate都属于ORM框架，为数据层提供持久化操作的支持 由于MyBatis更接近于JDBC的开发，所以相对于Hibernate更加的简单易学 Hibernate开发者不要关注SQL的生成和结果的映射，而Mybatis需要手动配置关系和SQL Hibernate与具体的数据库关联配置对应的XML即可，所执行的HQL语句与数据库无关，移植性强。而Mybatis直接使用的是SQL语句，相对没那么灵活，但是执行效率略高于Hibernate 三、Mybatis的优缺点 优点： SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，并可重用，适合多表的复杂查询 提供XML标签，支持编写动态SQL语句 提供映射标签，支持对象与数据库的ORM字段关系映射 缺点 SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求 SQL语句依赖于数据库，导致数据库移植性差，不可随意更换数据库 四、代码案例1、编写Mybatis核心配置文件【 mybatis-core.xml 】12345678910111213141516171819&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.fan.entity.StudentEntity" alias="StudentEntity"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/public"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="xxxMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 释意: typeAlias用于存放实体类别名的集合 — typeAlias中的type代表实体类 — alias代表别名 environments环境default里面的值可以是生产环境、测试环境、开发环境… transactionManager事务管理type默认为JDBC dataSource是数据库连接的基本信息 mapper中的resource代表应用实体类的Mapper的路径，里面的参数可以是resource=”xxxMapper.xml”或者url=”file:///C:/xxxMapper.xml” 2、编写实体类映射文件【 xxxMapper.xml 】123456789101112131415161718192021&lt;mapper namespace="StuMapper"&gt; &lt;select id="selCount" resultType="int"&gt; select count(*) from student &lt;/select&gt; &lt;select id="selById" parameterType="int" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.stuId = #&#123;id&#125; &lt;/select&gt; &lt;insert id="addOne" parameterType="StudentEntity"&gt; INSERT INTO student VALUES(NULL,#&#123;stuName&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;address&#125;,NULL) &lt;/insert&gt; &lt;delete id="delOne" parameterType="int"&gt; DELETE FROM student WHERE student.stuId = #&#123;id&#125; &lt;/delete&gt; &lt;update id="modifyOne" parameterType="StudentEntity"&gt; UPDATE student SET stuName = #&#123;stuName&#125; WHERE stuId = #&#123;stuId&#125; &lt;/update&gt;&lt;/mapper&gt; 释意: mapper中的namespace是独立唯一的 映射文件中支持写原生的SQL语句 id可以形象的理解为方法名，但是同时也是独立唯一的 parameterType代表调用时传过来的参数类型 resultType代表返回值类型 #{xxx} 可以理解为占位符 3、简单的使用123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; Reader reader = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory factory = null; SqlSession session = null; try &#123; //1.加载配置文件 reader = Resources.getResourceAsReader("mybatis-core.xml"); //2.得到工厂的创建对象 builder = new SqlSessionFactoryBuilder(); //3.得到工厂对象 factory = builder.build(reader); //4.得到session session = factory.openSession(); //5.执行语句 StudentEntity student = session.selectOne("StuMapper.selById", 100); //StuMapper--&gt; StudentMapper.xml中的namespace。 selById--&gt; 为其中的id 。 100--&gt; 实参 System.out.println("学生名为--&gt;" + student.getStuName()); session.commit(); //修改、新增语句记得提交事务 &#125; catch (Exception e) &#123; session.rollback(); e.printStackTrace(); &#125; finally &#123; if (session != null) &#123; session.close(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
