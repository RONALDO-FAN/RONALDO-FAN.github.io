<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis学习笔记(七)]]></title>
    <url>%2F2018%2F12%2F13%2Fjava%2Fmybatis%2Fmybatis7%2F</url>
    <content type="text"><![CDATA[一、Mybatis基于注解开发MyBatis3.0+ 提供了全面的基于注解开发，使用注解可以简化XML配置，但是注解方式并不是XML配置文件的替代者，因为有许多的操作注解并没有普及，而且注解是快速开发，不利于我们之后的维护和扩展。 二、Mybatis常用注解表注解目标对应的XML标签@CacheNamespace类&lt;cache&gt;@CacheNamespaceRef类&lt;cacheRef&gt;@Results方法&lt;resultMap&gt;@Result方法&lt;result&gt;&lt;id&gt;@One方法&lt;association&gt;@Many&nbsp;&nbsp;方法&lt;collection&gt;@Insert@Update@Delete方法&lt;insert&gt;&lt;update&gt;&lt;delete&gt;@InsertProvider@UpdateProvider@DeleteProvider@SelectProvider方法&lt;insert&gt;&lt;update&gt;&lt;delete&gt;&lt;select&gt;允许创建动态SQL@Param&nbsp;参数N/A@Options&nbsp;方法映射语句的属性@select方法&lt;select&gt; 三、基本SQL实例如下： 新增 123@Insert("INSERT INTO student(stuName,gender,age,address,deptIdd) VALUES(#&#123;stuName&#125;,#&#123;sex&#125;,#&#123;age&#125;,#&#123;address&#125;,#&#123;deptIdd&#125;)")@Options(useGeneratedKeys = true, keyColumn = "stuId")int saveOne(StudentEntity student); 删除 12@Delete("DELETE FROM student WHERE stuId = #&#123;stuId&#125;")int deleteOne(Integer id); 修改 123@Update("UPDATE student SET stuName = #&#123;stuName&#125;,gender = #&#123;sex&#125; WHERE stuId = #&#123;stuId&#125;")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;) //配置与列名不一致的属性即可int modifyOne(StudentEntity student); 查询 1234@Select("SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;) //配置与列名不一致的属性即可@Options(useCache = true,flushCache = false,timeout = 6000)List&lt;HashMap&gt; queryMany(); 四、动态SQL动态SQL的话我们需要创建，一个能帮我们动态返回的SQL语句类，然后Dao层接口通过反射调用其方法。实例如下： 新增 123@SelectProvider(type = TrendSQLProvider.class,method = "trendSaveOne")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;)Integer trendSaveOne(StudentEntity student); 删除 12@DeleteProvider(type = TrendSQLProvider.class,method = "trendDeleteOne")Integer trendDeleteOne(Integer id); 修改 123@UpdateProvider(type = TrendSQLProvider.class,method = "trendModifyOne")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;)Integer trendModifyOne(StudentEntity student); 查询 123@SelectProvider(type = TrendSQLProvider.class,method = "trendQueryStuList")@Results(value = &#123;@Result(property = "sex",column = "gender")&#125;)List&lt;StudentEntity&gt; trendQueryStuList(Map&lt;String, Object&gt; param); 上面四条curd执行语句都用到的type和method，分别代表着指定一个类和这个类中指定的方法 TrendSQLProvider类如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 生成动态SQL的工具类public class TrendSQLProvider &#123; /*新增*/ public String trendSaveOne(StudentEntity student) &#123; return new SQL() &#123; &#123; INSERT_INTO("student"); if (student.getStuId() != null) &#123; VALUES("stuId", "#&#123;stuId&#125;"); &#125; if (student.getStuName() != null) &#123; VALUES("stuName", "#&#123;stuName&#125;"); &#125; if (student.getSex() != null) &#123; VALUES("gender", "#&#123;sex&#125;"); &#125; if (student.getAge() != null) &#123; VALUES("age", "#&#123;age&#125;"); &#125; if (student.getAddress() != null) &#123; VALUES("address", "#&#123;address&#125;"); &#125; if (student.getDeptIdd() != null) &#123; VALUES("deptIdd", "#&#123;deptIdd&#125;"); &#125; &#125; &#125;.toString(); &#125; /*删除*/ public String trendDeleteOne(Integer id) &#123; return new SQL() &#123; &#123; DELETE_FROM("student"); if (id != null) &#123; WHERE("stuId = #&#123;id&#125;"); &#125; &#125; &#125;.toString(); &#125; /*修改*/ public String trendModifyOne(StudentEntity student) &#123; return new SQL() &#123; &#123; UPDATE("student"); if (student.getStuName() != null) &#123; SET("stuName = #&#123;stuName&#125;"); &#125; if (student.getSex() != null) &#123; SET("gender = #&#123;sex&#125;"); &#125; WHERE("stuId = #&#123;stuId&#125;"); &#125; &#125;.toString(); &#125; /*查询*/ public String trendQueryStuList(Map&lt;String, Object&gt; param) &#123; return new SQL() &#123; &#123; SELECT("*"); FROM("student"); if (param.get("stuName") != null) &#123; WHERE("stuName like concat('%',#&#123;stuName&#125;,'%')"); &#125; if (param.get("age") != null) &#123; WHERE("age &gt;= #&#123;minAge&#125;"); &#125; &#125; &#125;.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(六)]]></title>
    <url>%2F2018%2F12%2F13%2Fjava%2Fmybatis%2Fmybatis6%2F</url>
    <content type="text"><![CDATA[一、Mybatis缓存机制 mybatis提供了强大的缓存机制减轻数据库压力，提高数据库性能 mybatis的缓存分为：一级缓存、二级缓存 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的 如果SqlSession执行了DML操作（insert、update、delete），并提交事务了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的数据永远和数据库中一致，避免出现脏读取 二、一级缓存 MyBatis的一级缓存默认开启的 第一次执行查询完毕后，会将查到的数据写入SqlSession内的HashMap中缓存起来 第二次如果执行相同的查询，会直接到从缓存中返回数据，从而提高了效率 实例，执行两次相同的查询 123456789public static void main(String[] args) &#123; SqlSession session= MybatisUtil.getSession(); StudentEntity stu0 = session.selectOne("StuMapper.queryOne", 100); System.out.println(stu0.getStuName() + "--" + stu0.getGender()); MybatisUtil.colseSession(); //执行第二次相同查询时，先关闭Session SqlSession session= MybatisUtil.getSession(); //然后再次开启 StudentEntity stu1 = session.selectOne("StuMapper.queryOne", 100); System.out.println(stu1.getStuName() + "--" + stu1.getGender());&#125; 执行的结果，我们可以从中看出两次查询，系统默认只执行了一次SQL查询 三、二级缓存 MyBatis的二级缓存不是默认开启的 二级缓存是mapper级别的缓存，也就是同一个namespace的xxxMapper.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域 实例 在Mybatis核心配置文件【 mybatis-core.xml 】中开启缓存 123&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 在须要开启二级缓存的【 xxxMapper.xml 】中配置缓存 1&lt;cache eviction="LRU" flushInterval="60000" size="2048" readOnly="true"/&gt; 这里配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的 参数详情表 选项 默认值 eviction 可用资源的回收策略，主要包含如下几种: LRU：较少使用的、移除最长时间不被使用的对象FIFO：(先进先出)：按对象进入缓存的顺序将其移除SOFT(软引用)：移除基于垃圾回收器状态和软引用规则的对象WEAK(弱引用)：积极地移除基于垃圾收集器状态和弱引用规则的对象 flushInterval 刷新间隔，可以被设置为任意的正整数，它们代表一个合理的毫秒形式的时间段。默认情况下不设置，即没有刷新间隔，缓存仅在调用语句时刷新 size 引用数目，可以被设置为任意正整数，要牢记缓存的对象数目和运行环境的可用内存资源数目默认值为1024 readOnly 只读属性可以被设置为true或false只读的缓存设置会给所有调用者返回缓存对象的相同实例因此这些对象不能被修改。此处提供了很重要的性能优势可读写的缓存会返回缓存对象的拷贝（通过序列化这样较为缓慢，但比较安全，因此默认为false 执行结果如下]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题整理-基础篇(一)]]></title>
    <url>%2F2018%2F12%2F13%2Fjava%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%861%2F</url>
    <content type="text"><![CDATA[一、什么是Java JVM(java虚拟机)？ Java虚拟机是一个可以执行Java字节码的虚拟机进程，Java源文件被编译成能被Java虚拟机执行的字节码文件。 二、JDK、JRE、JVM关系是什么？ JDK（Java Development Kit）即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及JRE。开发工具如：用于编译java程序的javac命令、用于启动JVM运行java程序的java命令、用于生成文档的javadoc命令以及用于打包的jar命令等等。 JRE（Java Runtime Environment）即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。 JVM（Java Virtual Machines）即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。 三、Tomcat的优化经验 去掉对web.xml的监视，把JSP提前编辑成Servlet；有富余物理内存的情况下，加大Tomcat使用的JVM内存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(五)]]></title>
    <url>%2F2018%2F12%2F12%2Fjava%2Fmybatis%2Fmybatis5%2F</url>
    <content type="text"><![CDATA[一、Mybatis关联映射在实际的项目开发中，我们不可能只对单表进行操作。从而有了一对一、一对多、多对一的多表关联，以下采用学生表(Student)和系表(Department)进行操作。 二、多对一 如学生表(Student)对应系表(Department)构成多对一关系 学生实体 12345678public class StudentEntity implements Serializable &#123; private Integer stuId; private String stuName; private String sex; //此字段与数据库列名不一致 /* 多对一关联系表的属性 */ private DepartmentEntity dept; 省略get、set方法...&#125; DepartmentMapper.xml 系映射文件 123&lt;resultMap id="deptMap" type="DepartmentEntity" autoMapping="true"&gt; &lt;id property="deptId" column="deptId"/&gt;&lt;/resultMap&gt; StudentMapper.xml 学生映射文件 12345&lt;resultMap id="stuJoinDept" type="StudentEntity" autoMapping="true"&gt; &lt;id property="stuId" column="stuId"/&gt; &lt;result property="sex" column="gender"/&gt; &lt;!-- 因为属性名和列名不同所以要单独做映射 --&gt; &lt;association property="dept" javaType="DepartmentEntity" resultMap="com.fan.dao.IDepartmentDao.deptMap"/&gt;&lt;/resultMap&gt; PS 如果映射文件使用了autoMapping=”true”时，表示自动映射列名和属性名相同的属性，不相同的就要单独做映射 ID列是必须带有的 association标签是多对一的关键字，property属性填写当前实体关联的实体，javaType属性填写当前关联实体的类型，resultMap属性填写关联实体resultMap的ID SQL配置123&lt;select id="queryStuOne" parameterType="int" resultMap="stuJoinDept"&gt; SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId where s.stuId = #&#123;stuId&#125;&lt;/select&gt; 三、一对多 如系表(Department)对应学生表(Student)构成一对多关系 系实体 1234567public class DepartmentEntity implements Serializable &#123; private Integer deptId; private String departName; /* 一对多关联学生表的属性 */ private List&lt;StudentEntity&gt; stuList = new ArrayList&lt;&gt;(); 省略get、set方法...&#125; StudentMapper.xml 系映射文件 1234&lt;resultMap id="stuMap" type="StudentEntity" autoMapping="true"&gt; &lt;id property="stuId" column="stuId"/&gt; &lt;result property="sex" column="gender"/&gt; &lt;!-- 因为属性名和列名不同所以要单独做映射 --&gt;&lt;/resultMap&gt; DepartmentMapper.xml 系映射文件 1234&lt;resultMap id="deptJoinStu" type="DepartmentEntity" autoMapping="true"&gt; &lt;id property="deptId" column="deptId"/&gt; &lt;collection property="stuList" javaType="arrayList" ofType="StudentEntity" resultMap="com.fan.dao.IStudentDao.stuMap"/&gt;&lt;/resultMap&gt; PS collection 标签是一对多的关键字，property属性填写当前实体关联的实体，javaType属性填写当前关联实体的类型，resultMap属性填写关联实体resultMap的ID SQL配置123&lt;select id="queryDeptToStuList" resultMap="deptJoinStu"&gt; SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId&lt;/select&gt; 四、利用HashMap的“万能关联”由于Mybatis的关联是很灵活的，不管几对几，我们都可以不用任何关联配置。 Dao层接口 123public interface IStudentDao &#123; List&lt;HashMap&gt; queryStuListByMap(); //查询全部学的详情&#125; List集合中的类型必须是HashMap SQL配置 123&lt;select id="queryStuListByMap" parameterType="map" resultType="map"&gt; SELECT * FROM student as s INNER JOIN department as d ON s.deptIdd = d.deptId&lt;/select&gt; 返回值的类型必须是HashMap 调用 12345678public static void main(String[] args) &#123; SqlSession session = MybatisUtil.getSession(); IStudentDao studentDao = session.getMapper(IStudentDao.class); List&lt;HashMap&gt; list = studentDao.queryStuListByMap(); for (HashMap stu : list) &#123; System.out.println(stu.get("stuName") + "--" + stu.get("gender") + "--" + stu.get("departName")); &#125;&#125; 通过获取HashMap中的Key得到Value]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用宝塔面板上传Java Web项目]]></title>
    <url>%2F2018%2F12%2F11%2Fserver%2F%E4%B8%8A%E4%BC%A0Java%20Web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一、安装宝塔Linux面板 6.7 系统要求 支持 CentOS、Ubuntu、Debian、Fedora、Deepin系统 确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL 内存要求最低512MB 使用SSH连接工具连接到您的 Linux 服务器后，执行如下Centos安装指令1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 二、环境安装 进入你的宝塔服务器控制面板 安装 Tomcat [ 默认安装好tomcat时给你自带JDK，例如 tomcat7对应JDK1.7 tomcat8对应JDK1.8… ] MySQL [ 推荐安装Mysql5.5 or 5.7 ] Nginx [ 推荐安装Nginx 1.14.1 ] 其他根据需求而定 三、部署项目未完待续]]></content>
      <tags>
        <tag>原创</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(四)]]></title>
    <url>%2F2018%2F12%2F10%2Fjava%2Fmybatis%2Fmybatis4%2F</url>
    <content type="text"><![CDATA[一、Mybatis面向接口编程Mybatis面向接口编程是mybatis的独有的特性。对比之前的Hiberbate我们通常是定义好一个Dao层接口，然后在定义一个DaoImpl的实现进行编程，这样定义结构清晰，方便维护和扩展。如果用mybatis处理Dao层的话，就可以直接省略实现类，直接在mapper.xml配置文件中编写，这样就可以通过接口访问映射文件。 二、代码实例 Dao层接口 1234public interface IBillDao &#123; /*根据名称模糊查询所有的订单*/ List&lt;BillEntity&gt; queryBillByName(String productName);&#125; Mapper.xml映射文件 12345&lt;mapper namespace="com.fan.dao.IBillDao"&gt; &lt;select id="queryBillByName" parameterType="String" resultType="BillEntity"&gt; SELECT * FROM smbms_bill WHERE productName LIKE concat('%',#&#123;productName&#125;,'%') &lt;/select&gt;&lt;/mapper&gt; Main方法调用 12345678public static void main(String[] args) &#123; SqlSession session = MybatisUtil.getSession(); IBillDao billDao = session.getMapper(IBillDao.class); List&lt;BillEntity&gt; list = billDao.queryBillByName("饮料"); for (BillEntity bill : list) &#123; System.out.println(bill.getBillCode() + "--" + bill.getProductName()); &#125;&#125; PS Mapper.xml映射文件中namespace必须是 ‘包名.接口名’，如com.fan.dao.IBillDao Mapper.xml映射文件中Id必须与 接口的方法名一致 调用时通过session.getMapper(接口.class)，获得接口实例]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(三)]]></title>
    <url>%2F2018%2F12%2F10%2Fjava%2Fmybatis%2Fmybatis3%2F</url>
    <content type="text"><![CDATA[一、Mybatis动态SQL本篇所讲的使用mybatis动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。 二、基本标签 If标签 123456789&lt;select id="queryByCondition" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student WHERE 1 = 1 &lt;if test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/if&gt; &lt;if test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/if&gt;&lt;/select&gt; parameterType类型我们用到了一个自定义参数的实体类，当然可以使用map集合替代 如果studentName和minAge全部满足条件 1SELECT * FROM student WHERE 1 = 1 AND studentName like ? AND minAge= ? 如果全不满足条件 1SELECT * FROM student WHERE 1 = 1 Where标签 + If标签 1234567891011&lt;select id="queryByWhere" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student &lt;where&gt; &lt;if test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/if&gt; &lt;if test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where元素的作用是在写入where元素的地方输出一个where MyBatis会智能处理输出条件，如果所有条件都不满足，那么MyBatis会查出所有的记录 如果输出后是以and开头的，MyBatis会把第一个and忽略 因此不用写1=1这样的条件 Set标签 + Where标签 123456789101112&lt;update id="modifyOne" parameterType="StudentEntity"&gt; UPDATE student &lt;set&gt; &lt;if test="stuName != null"&gt; stuName = #&#123;stuName&#125;, &lt;/if&gt; &lt;if test="gender != null"&gt; gender = #&#123;gender&#125;, &lt;/if&gt; &lt;/set&gt; WHERE stuId = #&#123;stuId&#125;&lt;/update&gt; 注意的是，if语句里面的需要以 ‘,’ 逗号结尾，如果只有一条语句合适的话，mybatis会自动处理最后的逗号 如果studentName和minAge全部满足条件 1UPDATE student SET stuName = ? AND gender = ? WHERE stuId = ? 如果全不满足条件，就不会做出任何修改 Choose(when,Otherwise)标签 1234567891011121314&lt;select id="queryByCondition" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student WHERE 1 = 1 &lt;choose&gt; &lt;when test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/when&gt; &lt;when test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/when&gt; &lt;otherwise&gt; and state = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 不论在什么情况下都会执行otherwise标签，例如1SELECT * FROM student WHERE 1 = 1 and state = 1 Trim标签 trim标记是一个格式化的标记，可以完成Set或者是Where标记的功能 例如分别修改查询和更新语句 1234567891011&lt;select id="queryByTrim" parameterType="com.fan.entity.ConditionEntity" resultType="StudentEntity"&gt; SELECT * FROM student &lt;trim prefix="WHERE" prefixOverrides="and|or"&gt; &lt;if test="studentName != null"&gt; and stuName like concat('%',#&#123;studentName&#125;,'%') &lt;/if&gt; &lt;if test="minAge != null"&gt; and age &gt;= #&#123;minAge&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; prefix代表前缀 prefixoverride代表去掉第一个and或者是or 1234567891011&lt;update id="modifyOneByTrim" parameterType="StudentEntity"&gt; UPDATE student &lt;trim prefix="SET" suffix="WHERE stuId = #&#123;stuId&#125;" suffixOverrides=","&gt; &lt;if test="stuName != null"&gt; stuName = #&#123;stuName&#125;, &lt;/if&gt; &lt;if test="gender != null"&gt; gender = #&#123;gender&#125;, &lt;/if&gt; &lt;/trim&gt;&lt;/update&gt; suffix代表前缀，一般把最后的条件语句写在里面 suffixOverrides代表去掉最后一个 ‘,’ 逗号 三、Foreach标签 foreach标签操作需求是对一个集合进行遍历，通常是在构建IN条件语句的时候，我们通常用作批量删除、添加、和in查询字句 实例 123456&lt;delete id="delBatch"&gt; DELETE from student WHERE stuId in &lt;foreach collection="array" item="id" open="(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/delete&gt; 调用 先定义一个int类型的数组，然后作为参数后传入 1234567static void delBatch(SqlSession session) &#123; int[] theArr = new int[]&#123;123, 124, 125&#125;; int res = session.delete("StuMapper.delBatch", theArr); if (res &gt; 0) &#123; System.out.println("删除成功：" + res); &#125;&#125; 释意 collection代表传入的参数类型，常用的有array、list、map三种，分别对应的参数类型为数组、List、Map集合 item代表迭代过程中的每一个元素的别名 index代表每次迭代的下标 open代表前缀 cloase代表后缀 separator分隔符，表示迭代时每个元素之间以什么分隔 四、Bind、多数据库支持 了解应用后带来…]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架简述]]></title>
    <url>%2F2018%2F12%2F09%2Fjava%2F%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、起步集合类都位于java.util包下，Java 集合框架主要包括两种类型的容器，一种是集合（Collection）,存储一个元素集合;另一种是图（Map）,存储键/值对映射。支持序列化 二、Collection接口1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125; 查看源码发现Collection是一个接口类，其继承了java迭代接口Iterable 有三个主要的子接口List、Set 和 Queue，记住Map不是Collection的子接口!! 存储特点允许重复的对象 常用的方法 三、List接口1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; 查看源码发现List是一个接口类，其继承了Collection接口，它可以定义一个允许重复的有序集合 List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引 List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 实现List接口的集合主要有： (1) ArrayList 1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable&#123;&#125; ArrayList继承于AbstractList，实现了List、RandomAccess、Cloneable、Serializable接口 ArrayList是一个动态数组，也是我们最常用的集合 它允许任何符合规则的元素插入甚至包括null 每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小，但是数组大小是动态的 总的特点:基于数组实现，非线程安全，便于索引，查询效率高，但不便于插入和删除 (2) LinkedList 1public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable&#123;&#125; LinkedList继承于AbstractSequentialList，实现了List，Deque，Cloneable，Serializable接口 LinkedList是一个双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低 它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部进行操作 有个重要的内部类Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 总的特点:基于链表实现，链表内存是散乱的，每一个元素本身内存地址的同时还存储下一个的地址，链表增删快，查找慢 (3) Vector 1public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable&#123;&#125; Vector继承于AbstractList，实现了List，RandomAccess，Cloneable，Serializable接口 与ArrayList相似，但是Vector是同步的 Vector是线程安全的动态数组 总的特点:基于数组实现，线程安全的，效率低 四、Map接口1public interface Map&lt;K,V&gt; &#123;&#125; 查看源码发现Map是一个接口类，但是它不继承或者实现任何类或接口 Map与List、Set接口不同，它是由一系列键值对组成的集合 提供了key到Value的映射 Map中它保证了key与value之间的一一对应关系 它不能存在相同的key值，而value值可以相同 实现Map接口的集合主要有： (1) HashMap 1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; HashMap继承于AbstractMap，实现了Map，Cloneable，Serializable接口 HashMap 是一个散列表，它存储的内容是键值对(key-value)映射 HashMap 的实现不是同步的，这意味着它不是线程安全的 HashMap中的映射不是有序的 总的特点:基于hash表的Map接口实现，非线程安全的，效率高，key、value都可以为null (2) HashTable 1public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; HashTable继承于Dictionary，实现了Map，Cloneable，Serializable接口 HashTable 是一个散列表，它存储的内容是键值对(key-value)映射 HashTable的实现是同步的，这意味着它是线程安全的 HashTable中的映射不是有序的 总的特点:基于hash表的Map接口实现，线程安全的，效率低，key、value都不可以为null (3) LinkedHashMap 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; LinkedHashMap继承于HashMap，实现了 Map接口 LinkedHashMap是一个HashMap的子类，它保留插入的顺序 如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap LinkedHashMap是Map接口哈希表和链接列的实现，具有可预知的迭代顺序 总的特点:基于HashMap，保存了记录的插入顺序，非线程安全的，key、value都可以为null 五、Set接口1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; 查看源码发现Set是一个接口类，其继承了Collection接口 Set中的元素实现了不重复，有点象集合的概念 由于Set接口的特殊性，所有传入Set集合中的元素都必须不同 最多允许有一个null元素对象 无序，不允许有重复的元素 虽然Set中元素没有顺序，但是元素在set中的位置是有由该元素的HashCode决定的，其具体位置其实是固定的 实现Set接口的集合主要有： (1) HashSet 1public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable&#123;&#125; HashSet继承于AbstractSet，实现了Set，Cloneable，Serializable接口 HashSet是一个没有重复元素的集合，它是由HashMap实现的，不保证元素的顺序 HashSet允许使用null元素，但是非同步的 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能 HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象 总的特点:基于HashMap，不允许集合中有重复的值，使用该方式时需要重写equals()和hashCode()方法 (2) LinkedHashSet 1public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable &#123;&#125; LinkedHashSet继承于HashSet，实现了Set，Cloneable，Serializable接口 LinkedHashSet底层是基于LinkedHashMap来实现的，有序非同步 LinkedHashSet集合是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序 LinkedHashSet将会以元素的添加顺序访问集合的元素 总的特点:基于HashMap，不允许集合中有重复的值，保存了记录的插入顺序 (2) TreeSet 1public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable &#123;&#125; TreeSet继承于AbstractSet，实现了NavigableSet，Cloneable，Serializable接口 TreeSet是一个有序集合 TreeSet可以确保集合元素处于排序状态 TreeSet支持两种排序方式，自然排序和定制排序 TreeSet通过compare或者comparaeTo函数来判断元素是否相等 总的特点:基于TreeMap，非线程安全，非同步的]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo-Github域名绑定(阿里云)]]></title>
    <url>%2F2018%2F12%2F09%2Fhexo%2Fhexo%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[一、起步 Node.js Git Hexo GitHub环境已搭建 域名已经实名认证 二、开始 得到GitHub仓库名[ 如crbug.github.io ]的IP值我的是 185.199.111.153 域名解析 打开阿里云域名控制台点击解析后点击新手引导，填入我们之前CMD命令ping好的值–&gt;如185.199.111.153会给我们生成两条A记录值修改第一条A值为CNAME值(CNAME记录的记录值为域名形式（如abc.example.com）)，其值填写自己GitHub仓库名即可 三、修改GitHub仓库 进入自己Hexo的仓库，点击设置 往下滑找到当前页面GitHub Pages项中的Custom domain，修改值为自己的域名 四、修改本地Hexo 进入Hexo项目下的source文件夹，创建一个文件命名为CNAME，里面填写自己需要绑定的阿里云域名，等待10分钟左右即可]]></content>
      <tags>
        <tag>原创</tag>
        <tag>Hexo指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上帝偏爱奔跑者]]></title>
    <url>%2F2018%2F12%2F08%2Farticle%2F%E4%B8%8A%E5%B8%9D%E5%81%8F%E7%88%B1%E5%A5%94%E8%B7%91%E8%80%85%2F</url>
    <content type="text"><![CDATA[&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;2013年，英超豪门阿森纳足球俱乐部的官方网站发布了一部短片，纪念一位越南的“Running Man”（奔跑者）。片头是：每一个故事里都有一个英雄，在这一次的旅途中，英雄出现了——The Running Man。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;短片一经发布，这位越南球迷即刻风靡全球。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;发布前一天，阿森纳队刚刚抵达越南。作为一支英超球队，此番访问越南尚属首次。因此，他们一到，立即引起了轰动。一群狂热的球迷一路奔跑，追赶着偶像乘坐的大巴车。可是，路途很长，车速也不慢。许多人在追赶一段后便放弃了。可是，有一个小伙子却一直坚持着。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;小伙子20岁上下，肤色黝黑，笑容爽朗。尽管大巴车一直以较快的速度前行，可是，他奔跑的速度也不慢，总能适时跟上。小伙子不断地朝车内的群星微笑，向他们挥手，向他们竖起大拇指。车内，球星们也不断回应，露出善意的笑容。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;大步奔跑，不断挥手示意，始终不渝地微笑着。这样的奔跑画面感染了每一位阿森纳球员。他们不断地朝他挥手、微笑、呐喊。车有多快，奔跑便有多快。那是一条长长的道路，途经闹市、街道、人群……一边望向车内，一边急速奔跑，他免不了摔跤。是的，他因一根灯柱而摔倒过，他因一棵大树而撞着了头……每一次，当他摔倒的时候，球星们便发出遗憾之叹。可是随即，他们又欢呼起来：这位了不起的小伙子迅速从地上爬起，仍然保持着那爽朗的笑容，向他们挥手，跟着他们继续前行。他不曾停歇。他只知道，他要一直追赶他们。就如夸父一样，这是一个奔向太阳的史诗般的“英雄”。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;目睹这位充满激情的小伙子奔跑、跌倒、爬起、微笑、再奔跑的过程，球星们对他肃然起敬。所有的球员都跑向车厢那一侧，对他唱了起来：“Sign him up（签下他）！Sign him up……”当然，这是玩笑话，但是，这位球迷身上的热情与激情深深打动了他们。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;他跑了足足5公里。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;他终于乏了。不过，他没有停下，而是换乘一辆摩托车，继续他的“追梦”之路。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;看着他如此不懈地追逐，带队教练终于发话，停下车，为他开启了一扇通向梦想的大门——他有了与阿森纳球员零距离接触的机会。见自己的奔跑没有白费，他振臂欢呼。与他一齐欢呼的，还有车上所有的队员和教练。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;车内，所有的球星一一起立，迎接这位他们刚刚“签下”的新成员。小伙子与他们握手、拥抱、合影，求取签名。他与阿尔特塔并肩而坐，一只手友好地搭在这位著名球星的肩上，另一只手则振臂高呼。这样的一张照片成了阿森纳与球迷合影的经典之照。前锋吉鲁把这一过程完整地拍了下来。当他把视频放上Facebook时，全世界的人都惊叹了。有网友评论：“惊人的耐力、体力和忠诚度！难道他就是温格传说中的7000万引援？签了他！”&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;这是幽默而善意的评论，还有很多人为他喝彩。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;可是，更令人意外的是，2013年7月17日，当阿森纳队与越南队一同出现在绿茵球场时，这位“奔跑者”居然获得了与阿森纳球星一同出场的机会，成为阿森纳“名副其实”的“首发”球员。站在球场上，他与波多尔斯基谈笑风生。他参加双方球员例行的握手仪式。赛后，他还获得了温格赠送的机票、球票和酒店住宿待遇。于是，在将来的某一天，这位幸运的“奔跑者”将前往伦敦，去观看足球比赛。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;对于一位追梦的人来说，这也是他获得的最高礼遇。这位红透全世界的越南小伙子，在忘我的奔跑中追寻到了他的梦想。这不仅仅是一个球迷对于球星的向往和追求，更是关于青春、关于“梦”的追求。就在那样疯狂的奔跑中，他实现了原本遥不可及的梦想。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;所有的球迷在为他高兴的同时，也在艳羡他的境遇。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;然而，并不是所有人都那么“幸运”。因为，世界上分为两种人：一种是奔跑者，一种是观望者。&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;而上帝，往往偏爱那些拼尽全力的疯狂的奔跑者。 文章来源链接：http://www.ledu365.com/a/lizhi/49888.html来源：乐读网]]></content>
      <tags>
        <tag>转载</tag>
        <tag>文章推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(二)]]></title>
    <url>%2F2018%2F12%2F07%2Fjava%2Fmybatis%2Fmybatis2%2F</url>
    <content type="text"><![CDATA[一、MybatisUtil工具类MybatisUtil工具类主要是为了简化开发、提升开发速率。在没整合Spring之前方便统一管理Session等好处。以下两个版本的代码所执行的结果一致，完整版考虑的周到代码健壮性更好，两版本没本质区别！ 完整版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MybatisUtil &#123; private static final String CONFIGFILE = "mybatis-core.xml"; //当前线程存在session中 private static final ThreadLocal&lt;SqlSession&gt; THREAD_LOCAL = new InheritableThreadLocal&lt;&gt;(); private static Reader reader = null; private static SqlSessionFactoryBuilder builder = null; private static SqlSessionFactory factory = null; //用静态代码块进行初始化 static &#123; try &#123; //加载配置文件 reader = Resources.getResourceAsReader(CONFIGFILE); //得到工厂创建对象 builder = new SqlSessionFactoryBuilder(); //得到工厂对象 factory = builder.build(reader); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //获得工厂对象 public static SqlSessionFactory getFactory() &#123; if (factory == null) &#123; factory = builder.build(reader); &#125; return factory; &#125; //得到session public static SqlSession getSession() &#123; SqlSession session = THREAD_LOCAL.get(); if (session == null) &#123; SqlSessionFactory factory = getFactory(); session = factory.openSession(); THREAD_LOCAL.set(session); &#125; return session; &#125; //关闭session public static void colseSession() &#123; SqlSession session = THREAD_LOCAL.get(); if (session != null) &#123; session.close(); &#125; THREAD_LOCAL.set(null); &#125;&#125; 简化版 1234567891011121314151617181920public class MybatisUtil &#123; private static SqlSessionFactory factory; static &#123; try &#123; factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-core.xml")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSession() &#123; return factory.openSession(false); //true 为自动提交事务 &#125; public static void closeSession(SqlSession sqlSession) &#123; if (null != sqlSession) &#123; sqlSession.close(); &#125; &#125;&#125; 二、自增、模糊查询、分页查询及Map传参 设置主键自动增长 123&lt;insert id="saveOne" parameterType="StudentEntity" useGeneratedKeys="true" keyProperty="stuId"&gt; INSERT INTO student VALUES(NULL,#&#123;stuName&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;address&#125;,NULL)&lt;/insert&gt; 释意: useGeneratedKeys表示是否使用JDBC的getGenereatedKeys方法获取主键，并赋值到keyProperty设置的属性中 keyProperty需要自动增长的主键名称 模糊查询 123&lt;select id="queryByVague" parameterType="String" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.stuName like concat('%',#&#123;stuName&#125;,'%')&lt;/select&gt; 释意: MySQL中concat函数，返回结果为拼接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL 使用Map集合传参 123&lt;select id="queryByFactor" parameterType="map" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.gender = #&#123;gender&#125; AND student.age &gt; #&#123;minAge&#125;&lt;/select&gt; 释意: 调用时注意map集合里面的键一定要与传参命名一致 1234Map parame = new HashMap();parame.put("gender", "男");parame.put("minAge", 30);List&lt;StudentEntity&gt; list = session.selectList("StuMapper.selMap", parame); 别名与Java类型映射表(常用类型) 别名 映射的类型 boolean Boolean string String double Double int Intrger intrger Intrger list List arraylist ArrayList map Map hashMap HashMap 分页查询 123&lt;select id="queryByPage" parameterType="map" resultType="StudentEntity"&gt; SELECT * FROM student WHERE gender = #&#123;gender&#125; ORDER BY stuId DESC LIMIT #&#123;start&#125;,#&#123;end&#125;&lt;/select&gt; 释意: 调用时仍然采用map集合传参，注意下分页的页码12345Map parame = new HashMap&lt;&gt;();parame.put("gender", "男");parame.put("start", (pageNo - 1) * pageSize);parame.put("end", pageSize);List&lt;StudentEntity&gt; list = session.selectList("StuMapper.queryByPage", parame); 三、当实体类的属性和数据库中表的列名不一致 需要在映射文件中重新绑定属性与列名 123&lt;resultMap id="diyMapping" type="StudentEntity" autoMapping="true"&gt; &lt;result property="sex" column="gender"/&gt;&lt;/resultMap&gt; 释意: id代表这个resultMap的唯一标识 type代表需要重新映射的实体类也可以是之前设置的别名 autoMapping=”true”表示自动映射列名和属性名相同的属性，不相同的就要单独做映射 下面语句中的resultMap填写上面的ID即可123&lt;select id="queryCount" resultMap="diyMapping"&gt; select count(*) from student&lt;/select&gt;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pjax]]></title>
    <url>%2F2018%2F12%2F06%2Fjquery%2Fpjax%2F</url>
    <content type="text"><![CDATA[Pjax是一个jQuery插件，它通过ajax和pushState技术提供了极速的（无刷新ajax加载）浏览体验，并且保持了真实的地址、网页标题，浏览器的后退（前进）按钮也可以正常使用。 一、我眼中的PjaxPjax === PushState(修改地址栏的Url) + Ajax(异步无刷新技术)。简单的来说pjax是这两个技术的结合，执行原理ajax负责去后端请求部分html片段或者json数据，通过渲染到指定的div容器中，再由pushstate刷新当前的url地址，但是并不会造成页面的闪动，因此提升用户网页浏览体验。 二、Pjax的工作原理pjax的工作原理是通过ajax从服务器端获取HTML，在页面中用获取到的HTML替换指定容器元素中的内容。然后使用pushState技术更新浏览器地址栏中的当前地址。 三、Pjax的优缺点 优点： 不存在页面资源（js/css）的重复加载和应用 如果服务器端配置了pjax，它可以只渲染页面局部内容，从而避免服务器渲染完整布局的额外开销 缺点 不支持一些低版本的浏览器(如IE系列)，因为pushState是html5中history的新特性，在某些旧版浏览器中可能不支持 使服务端处理变得复杂 pjax依赖于jQuery 1.8或者更高版本 四、Pjax起步 通过npm安装 or 通过js引入(首先得引入jqeury)12$ npm install jquery-pjaxhttps://raw.github.com/defunkt/jquery-pjax/master/jquery.pjax.js 五、Pjax方法 $.fn.pjax 概述 1$(document).pjax(selector, [container], options) 1.selector：string类型，用于click 事件委托的选择器 2.container：string类型，用于标识唯一pjax容器的选择器 3.options object类型，包含下列选项 选项 默认值 说明 timeout 650 ajax超时时间（毫秒），超时后强制刷新整个页面 push true 使用 pushState 在浏览器中添加历史记录 replace false 替换URL地址但不添加浏览器历史记录 type “GET” 请求类型 dataType “html” 服务器端返回的数据类型 type “GET” 请求类型 url link.href string或function，返回ajax请求响应的URL 全局使用$.pjax.defaults对象改变默认配置，如下 $.pjax.defaults.timeout = 1200 $.fn.pjax 用法 最简单常见的pjax使用方法如下： 1$(document).pjax('a', '#pjax-container') pjax()方法能若干个参数，上文涉及到的‘a’和’#pjax-container’。‘a’代表所有的a标签链接，而‘#pjax-container’代表需要替换内容的容器。通过这种方式可以让页面中所有的链接都实现pjax加载，并指定ID为pjax-container的作为容器元素。 如果我们想指定a标签作为pjax链接使用方法如下： 1$(document).pjax('[data-pjax] a, a[data-pjax]', '#pjax-container') 那么我们可以用data-pjax来注明这是一个pjax链接，然后使用a[data-pjax]来代替全局选择器a。 六、事件 $.pjax.click 点击事件 本示例使用当前的click上下文来设置一个祖先元素作为容器：1234567if ($.support.pjax) &#123; $(document).on('click', 'a[data-pjax]', function(event) &#123; var container = $(this).closest('[data-pjax-container]') var containerSelector = '#' + container.id $.pjax.click(event, &#123;container: containerSelector&#125;) &#125;)&#125; $.pjax.submit 表单提交事件 通过pjax提交表单123$(document).on('submit', 'form[data-pjax]', function(event) &#123; $.pjax.submit(event, '#pjax-container')&#125;) $.pjax.reload 重载事件 使用pjax机制发起一个当前URL的请求到服务器，并且通过响应的内容替换容器元素中的内容，同时不添加浏览器历史记录。1$.pjax.reload('#pjax-container', options) $.pjax 手动调用pjax事件 主要用于非click事件发起pjax请求的情况。如果可以获得click事件，请使用$.pjax.click(event)来代替。1234function applyFilters() &#123; var url = urlForFilters() $.pjax(&#123;url: url, container: '#pjax-container'&#125;)&#125; 七、文档链接：https://github.com/defunkt/jquery-pjax来源：github链接：http://bsify.admui.com/jquery-pjax/来源：bsify]]></content>
      <tags>
        <tag>转载</tag>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活在你的时区]]></title>
    <url>%2F2018%2F12%2F06%2Farticle%2F%E6%B4%BB%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%97%B6%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[纽约时间比加州时间早三个小时，New York is 3 hours ahead of California但加州时间并没有变慢。but it does not make California slow有人22岁就毕业了，Someone graduated at the age of 22但等了五年才找到好的工作！but waited 5 years before securing a good job有人25岁就当上CEO，却在50岁去世。Someone became a CEO at 25，and died at 50也有人迟到50岁才当上CEO，然后活到90岁。While another became a CEO at 50 and lived to 90 years.有人依然单身，同时也有人已婚。Someone is still single，while someone else got married.奥巴马55岁就退休，川普70岁才开始当总统。Obama retires at 55，but Trump starts at 70世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone身边有些人看似走在你前面，People around you might seem to go ahead of you也有人看似走在你后面。some might seem to be behind you但其实每个人在自己的时区都有自己的步伐。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours生命就是等待正确的行动时机。Life is about waiting for the right moment to act所以，放轻松、你没有落后、你没有领先。So, RELAX、You’re not LATE、You’re not EARLY在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 文章来源作者：HIGO链接：https://www.zhihu.com/question/38874036/answer/458029368来源：知乎]]></content>
      <tags>
        <tag>转载</tag>
        <tag>文章推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用指令]]></title>
    <url>%2F2018%2F12%2F06%2Fhexo%2Fhexo-order%2F</url>
    <content type="text"><![CDATA[一、Hexo安装及初始化123npm install hexo-cli -g #安装npm update hexo -g #升级hexo init #初始化 二、常用指令 新建草稿 1hexo new draft "文章名称" 新建文章 1hexo n "文章名称" === hexo new "文章名称" 发布文章 1hexo publish "文章名称" 启动服务 1hexo s === hexo server 部署至服务器 1hexo d === hexo deploy 清除缓存 1hexo clean 更改端口 1hexo server -p 端口号 自定义IP 1hexo s -i ip地址 生成静态页面至public目录 1hexo g === hexo generate Ps:可与hexo g 合并为 hexo d -g / hexo g -d 三、插件推荐 1 文章置顶12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 文章添加top值即可 2 文章封面1npm install --save hexo-less 一张图片外链和less标签即可,该封面图不会出现在正文效果图如下 四、报错异常 1 找不到git部署及解决方法12ERROR Deployer not found: gitnpm install hexo-deployer-git --save 2 部署类型设置git –&gt;打开你博客的根目录，找到 _config.yml配置文件123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:github用户名/github用户名.github.io branch: master 五、查看更多详情 Hexo官方文档 https://hexo.io/zh-cn/ 大佬们的教程 https://segmentfault.com/a/1190000002632530 https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.bilibili.com/video/av17653359]]></content>
      <tags>
        <tag>原创</tag>
        <tag>Hexo指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记(一)]]></title>
    <url>%2F2018%2F12%2F05%2Fjava%2Fmybatis%2Fmybatis1%2F</url>
    <content type="text"><![CDATA[MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。是一个基于Java的持久层框架。 一、了解Mybatis MyBatis 是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集 MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录 二、与Hibernate对比 MyBatis与Hibernate都属于ORM框架，为数据层提供持久化操作的支持 由于MyBatis更接近于JDBC的开发，所以相对于Hibernate更加的简单易学 Hibernate开发者不要关注SQL的生成和结果的映射，而Mybatis需要手动配置关系和SQL Hibernate与具体的数据库关联配置对应的XML即可，所执行的HQL语句与数据库无关，移植性强。而Mybatis直接使用的是SQL语句，相对没那么灵活，但是执行效率略高于Hibernate 三、Mybatis的优缺点 优点： SQL写在XML里，从程序代码中彻底分离，降低耦合度，便于统一管理和优化，并可重用，适合多表的复杂查询 提供XML标签，支持编写动态SQL语句 提供映射标签，支持对象与数据库的ORM字段关系映射 缺点 SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求 SQL语句依赖于数据库，导致数据库移植性差，不可随意更换数据库 四、代码案例1、编写Mybatis核心配置文件【 mybatis-core.xml 】12345678910111213141516171819&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.fan.entity.StudentEntity" alias="StudentEntity"/&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/public"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="xxxMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 释意: typeAlias用于存放实体类别名的集合 — typeAlias中的type代表实体类 — alias代表别名 environments环境default里面的值可以是生产环境、测试环境、开发环境… transactionManager事务管理type默认为JDBC dataSource是数据库连接的基本信息 mapper中的resource代表应用实体类的Mapper的路径，里面的参数可以是resource=”xxxMapper.xml”或者url=”file:///C:/xxxMapper.xml” 2、编写实体类映射文件【 xxxMapper.xml 】123456789101112131415161718192021&lt;mapper namespace="StuMapper"&gt; &lt;select id="selCount" resultType="int"&gt; select count(*) from student &lt;/select&gt; &lt;select id="selById" parameterType="int" resultType="StudentEntity"&gt; SELECT * FROM student WHERE student.stuId = #&#123;id&#125; &lt;/select&gt; &lt;insert id="addOne" parameterType="StudentEntity"&gt; INSERT INTO student VALUES(NULL,#&#123;stuName&#125;,#&#123;gender&#125;,#&#123;age&#125;,#&#123;address&#125;,NULL) &lt;/insert&gt; &lt;delete id="delOne" parameterType="int"&gt; DELETE FROM student WHERE student.stuId = #&#123;id&#125; &lt;/delete&gt; &lt;update id="modifyOne" parameterType="StudentEntity"&gt; UPDATE student SET stuName = #&#123;stuName&#125; WHERE stuId = #&#123;stuId&#125; &lt;/update&gt;&lt;/mapper&gt; 释意: mapper中的namespace是独立唯一的 映射文件中支持写原生的SQL语句 id可以形象的理解为方法名，但是同时也是独立唯一的 parameterType代表调用时传过来的参数类型 resultType代表返回值类型 #{xxx} 可以理解为占位符 3、简单的使用123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; Reader reader = null; SqlSessionFactoryBuilder builder = null; SqlSessionFactory factory = null; SqlSession session = null; try &#123; //1.加载配置文件 reader = Resources.getResourceAsReader("mybatis-core.xml"); //2.得到工厂的创建对象 builder = new SqlSessionFactoryBuilder(); //3.得到工厂对象 factory = builder.build(reader); //4.得到session session = factory.openSession(); //5.执行语句 StudentEntity student = session.selectOne("StuMapper.selById", 100); //StuMapper--&gt; StudentMapper.xml中的namespace。 selById--&gt; 为其中的id 。 100--&gt; 实参 System.out.println("学生名为--&gt;" + student.getStuName()); session.commit(); //修改、新增语句记得提交事务 &#125; catch (Exception e) &#123; session.rollback(); e.printStackTrace(); &#125; finally &#123; if (session != null) &#123; session.close(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>原创</tag>
        <tag>后端</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
</search>
